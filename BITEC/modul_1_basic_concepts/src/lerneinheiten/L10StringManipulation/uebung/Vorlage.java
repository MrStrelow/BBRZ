public class Vorlage {

    public static void main(String[] args) {
        // Erstellen Sie einen Java-Code, der einen String einliest und dann die Anzahl der Zeichen in diesem String ausgibt.
        // (Verwenden Sie f√ºr die Ausgabe, sofern m√∂glich String.format(...))


        // Schreiben Sie ein Programm, das einen Namen als Eingabe erh√§lt und ihn in Gro√übuchstaben formatiert ausgibt.
        // (Verwenden Sie f√ºr die Ausgabe, sofern m√∂glich String.format(...))


        // Entwickeln Sie eine Anwendung, die einen Preis als `double` einliest, formatiert und mit 2 Dezimalstellen ausgibt.
        // (Verwenden Sie f√ºr die Ausgabe, sofern m√∂glich String.format(...))


        // Erstellen Sie eine Methode, die eine Telefonnummer im Format "1234567890" in das Format "(123) 456-7890" umwandelt.
       


        // Schreiben Sie ein Programm, das einen Text in umgekehrter Reihenfolge ausgibt (z.B. "Hallo" wird zu "ollaH").


        // Erstellen Sie ein Programm, das eine Zeichenkette entgegennimmt und alle Leerzeichen am Anfang und Ende entfernt.


        // Schreiben Sie eine Methode, die einen Text in Worte zerlegt und die Anzahl der Worte z√§hlt.


        // Entwickeln Sie eine Anwendung, die eine URL (z.B. "www.bbrz.at") in einen klickbaren HTML-Link umwandelt
        // (z.B. "<a href='http://www.bbrz.at'>www.bbrz.at</a>").
        // √úberpr√ºfen Sie dabei, ob die URL mit "http://" beginnt (f√ºgen Sie es ggf. hinzu)
        // und ob sie mit einer g√§ngigen TLD wie ".at", ".com", oder ".de" endet.


        // Entwickeln Sie eine Anwendung, die eine Temperatur in Grad Celsius in Grad Fahrenheit umrechnet
        // und das Ergebnis im Format $"25^{\circ}C \text{ entspricht } 77^{\circ}F"$ ausgibt.
        // (Umrechnungsformel: Celsius * 1,8 + 32 = Fahrenheit).


        // Schreiben Sie ein Programm, das eine Zeichenkette in ein festgelegtes L√§ngenformat umwandelt,
        // z.B. auf 10 Zeichen auff√ºllt (mit Leerzeichen am Ende) oder abschneidet.


        // Erstellen Sie ein Programm, das eine Prozentzahl (z.B. den Wert 0.25) im Format "25%" ausgibt,
        // wobei der Wert mit String.format angepasst wird.


        // ### Manipulationen
        //
        // Erstellen Sie ein Programm, das die folgenden Schritte nacheinander ausf√ºhrt:
        // 1.  Einlesen eines beliebigen Textes von der Konsole.
        // 2.  Ausgabe des Textes in Gro√übuchstaben.
        // 3.  Ausgabe der L√§nge des Originaltextes.
        // 4.  Anh√§ngen von ":-)" an den Originaltext und Ausgabe des Ergebnisses.
        // 5.  Ausgabe der ersten 5 Zeichen des Originaltextes (falls vorhanden, sonst so viele wie m√∂glich).
        // 6.  Ausgabe des ersten und letzten Zeichens des Originaltextes.
        // 7.  Ausgabe des 3. Zeichens des Originaltextes (Zeichen an Position 2, falls vorhanden).
        // 8.  Ausgabe des Originaltextes, nachdem alle Leerzeichen entfernt wurden.
        // 9.  Ausgabe des Originaltextes, nachdem alle '!' durch '#' ersetzt wurden.
        //
        // Beispielinteraktion:
        // ```
        // Text eingeben: Hallo Welt!
        // In Gro√übuchstaben: HALLO WELT!
        // L√§nge: 11
        // Mit Smiley: Hallo Welt!:-)
        // Erste 5 Zeichen: Hallo
        // Erstes Zeichen: H, Letztes Zeichen: !
        // 3. Zeichen: l
        // Ohne Leerzeichen: HalloWelt!
        // Ersetzt: Hallo Welt#
        // ```


        // ### US Noten
        //
        // * Schreiben Sie ein Programm, welches US-Noten in √∂sterreichische Schulnoten √ºbersetzt.
        // * Hierzu wird als erstes die US-Note abgefragt (A, B, C, D, F).
        // * Danach wird abh√§ngig von der Eingabe die √∂sterreichische Note ausgegeben.
        // * Noten-Mapping: A: 1, B: 2, C: 3, D: 4, F: 5.
        //
        // Beispiel:
        // ```
        // US-Note eingeben: C
        // √ñsterreichische Note: 3
        // ```


        // ### Zahlen drehen
        //
        // * Schreibe eine Methode, die die Ziffernreihenfolge einer Ganzzahl umdreht.
        //   Z.B: "Du hast die Zahl 153536758 eingegeben! Die umgedrehte Zahl lautet: 857635351".



        // ### E-Mail Adresse generieren
        //
        // * Implementieren Sie eine Konsolenabfrage von Vorname und Nachname.
        // * Die E-Mailadresse setzt sich folgenderma√üen zusammen:
        //     * 1. Buchstabe des Vornamens (kleingeschrieben)
        //     * "." (Punkt)
        //     * Nachname (kleingeschrieben)
        //     * "@bbrz.at"
        // * Beispiel:
        //     Vorname: Max
        //     Nachname: Mustermann
        //     Die E-Mail Adresse f√ºr Max Mustermann ist m.mustermann@bbrz.at


        // ### Entscheidungen treffen
        //
        // * F√ºhren Sie eine Konsolenabfrage des ersten Vornamens durch.
        // * Fragen Sie, ob die Person einen zweiten Vornamen hat (Eingabe "ja" oder "nein", Gro√ü-/Kleinschreibung soll ignoriert werden).
        // * Wenn die Eingabe "ja" ist:
        //     * Zweiter Vorname wird abgefragt.
        //     * Danach wird der Nachname abgefragt.
        //     * Ausgabe von Vorname, 2. Vorname und Nachname.
        // * Wenn die Eingabe "nein" ist:
        //     * Der Nachname wird abgefragt.
        //     * Ausgabe von Vorname und Nachname.
        // * Wenn die Eingabe weder "ja" noch "nein" ist:
        //     * Ausgabe von "Unbekannte Eingabe".


        // ### Uhrzeiten (Optionale √úbungen)
        //
        // Lesen Sie sich zuerst in die Formatierung und Verarbeitung von Uhrzeiten in Java ein
        // (z.B. mit `java.time.LocalTime`, `java.time.LocalDate`, `java.time.LocalDateTime`
        // und `java.time.format.DateTimeFormatter`).
        //
        // 1.  Schreiben Sie ein Java-Programm, das die aktuelle Uhrzeit im 24-Stunden-Format (hh:mm:ss) ausgibt.


        // 2.  Schreiben Sie ein Programm, das eine Zeichenkette mit einer Uhrzeit im Format "13:45" einliest
        //     und sie dann im 12-Stunden-Format (z.B. "01:45 PM") formatiert ausgibt.


        // 3.  Erstellen Sie ein Programm, das eine `LocalTime`-Instanz erh√§lt und die verbleibende Zeit bis Mitternacht (00:00:00)
        //     in Stunden, Minuten und Sekunden ausgibt.


        // 4.  Schreiben Sie ein Programm, das die aktuelle Uhrzeit mit Millisekunden formatiert (hh:mm:ss.SSS) und ausgibt.


        // 5.  Erstellen Sie ein Programm, das eine Uhrzeit im 24-Stunden-Format via Programmargumente als Zeichenkette (z.B. "18:30")
        //     akzeptiert und diese in eine `LocalTime`-Instanz konvertiert.


        // 6.  Schreiben Sie ein Java-Programm, das die aktuelle Uhrzeit in einer Zeile und das aktuelle Datum
        //     in einer anderen Zeile ausgibt.


        // 7.  Schreiben Sie ein Programm, das die aktuelle Uhrzeit und das aktuelle Datum in einem benutzerdefinierten Format
        //     (z. B. "Mittwoch, 27. Oktober 2023, 15:30 Uhr") ausgibt.


        // ### String-Grundlagen Í∏∞Ï¥à

        // Schreibe ein Java-Programm, das den Benutzer zur Eingabe eines Text-Strings auffordert. F√ºhre dann die folgenden Operationen durch und zeige die Ergebnisse an:
        
        // * **a) Umwandlung in Gro√übuchstaben**: Wandle den gesamten eingegebenen String in Gro√übuchstaben um.
        // * **b) Umdrehen mit StringBuilder**: Drehe den String mithilfe der eingebauten Methode der `StringBuilder`-Klasse um.
        // * **c) Manuelles Umdrehen**: Drehe den String *manuell* mithilfe einer Schleife (z.B. `for` oder `while`) und dem Zugriff auf einzelne Zeichen (`charAt()`) um. Verwende f√ºr diesen Teil **nicht** die `StringBuilder.reverse()`-Methode.
        // * **d) Palindrom-Pr√ºfung**:
        //     * Bereinige zuerst den eingegebenen String, indem du alle Leerzeichen entfernst und ihn in Kleinbuchstaben umwandelst.
        //     * √úberpr√ºfe dann, ob der bereinigte String ein Palindrom ist (d.h. vorw√§rts und r√ºckw√§rts gelesen gleich ist).
        //     * Gib aus, ob die urspr√ºngliche Eingabe (nach der Bereinigung) ein Palindrom ist oder nicht.
        
        
        // ### Zeichenanalyse üìä
        
        // Schreibe ein Java-Programm, das den Benutzer nach einem String fragt und dann eine Zeichenanalyse durchf√ºhrt:
        
        // * **a) Z√§hlung eines bestimmten Zeichens**:
        //     * Fordere den Benutzer auf, ein einzelnes Zeichen einzugeben, das gez√§hlt werden soll.
        //     * Fordere den Benutzer auf, einen Text-String einzugeben.
        //     * Z√§hle und zeige an, wie oft das angegebene Zeichen im Text-String vorkommt.
        // * **b) H√§ufigkeit aller Zeichen (eindeutig)**:
        //     * Fordere den Benutzer auf, einen Text-String einzugeben.
        //     * Iteriere durch den String und z√§hle f√ºr jedes Zeichen dessen Gesamtvorkommen im String.
        //     * Zeige die Anzahl f√ºr jedes Zeichen an, stelle dabei aber sicher, dass du die H√§ufigkeit f√ºr jedes eindeutige Zeichen nur *einmal* ausgibst. Wenn der String beispielsweise "banane" ist, sollte die Ausgabe 'b': 1, 'a': 3, 'n': 2 zeigen und 'a' nicht dreimal auflisten.
        //         * **Hinweis**: Du kannst einen Hilfs-String verwenden, um dir zu merken, f√ºr welche Zeichen die H√§ufigkeit bereits ausgegeben wurde.
        
        // ---
        
        // ### Wortzauberei üßô‚Äç‚ôÇÔ∏è
        
        // Erstelle ein Java-Programm, das die Anzahl der W√∂rter in einem gegebenen String z√§hlt. Implementiere eine robuste Benutzerf√ºhrung f√ºr die Eingabe:
        
        // * Fordere den Benutzer so lange zur Eingabe eines Text-Strings auf, bis eine g√ºltige Eingabe erfolgt.
        // * Der eingegebene String darf **nicht** leer sein.
        // * Der eingegebene String **muss** mindestens ein Leerzeichen enthalten (als einfache Methode, um sicherzustellen, dass potenziell mehrere W√∂rter vorhanden sind).
        // * Sobald eine g√ºltige Eingabe empfangen wurde, teile den String in W√∂rter auf und zeige die Gesamtzahl der W√∂rter an.
        //     * **Hinweis**: Die `split()`-Methode der `String`-Klasse wird hier sehr n√ºtzlich sein.
        
        // ---
        
        // ### Abwechselnde Gro√ü-/Kleinschreibung üîÑ
        
        // Schreibe ein Java-Programm, das die Gro√ü-/Kleinschreibung von Zeichen in einem vom Benutzer bereitgestellten String manipuliert.
        
        // * **a) Einfache abwechselnde Gro√üschreibung**:
        //     * Fordere den Benutzer zur Eingabe eines Strings auf.
        //     * Erstelle einen neuen String, bei dem Zeichen an geraden Indizes (0, 2, 4, ...) in Gro√übuchstaben umgewandelt werden und Zeichen an ungeraden Indizes in ihrer urspr√ºnglichen Schreibweise verbleiben.
        //     * Zeige den modifizierten String an.
        // * **b) Strikte abwechselnde Gro√ü-/Kleinschreibung**:
        //     * Fordere den Benutzer zur Eingabe eines Strings auf.
        //     * Erstelle einen neuen String, bei dem Zeichen an geraden Indizes in Gro√übuchstaben und Zeichen an ungeraden Indizes in Kleinbuchstaben umgewandelt werden.
        //     * Zeige den modifizierten String an.
        // * **c) Gefilterte strikte abwechselnde Gro√ü-/Kleinschreibung**:
        //     * Fordere den Benutzer zur Eingabe eines Strings auf.
        //     * Erstelle zuerst eine "bereinigte" Version des eingegebenen Strings, die *nur* alphabetische Zeichen (a-z, A-Z) enth√§lt. Verwirf alle anderen Zeichen (Zahlen, Symbole, Leerzeichen usw.).
        //         * **Hinweis**: Du kannst einen "Whitelist"-String mit erlaubten Zeichen definieren und f√ºr jedes Zeichen der Eingabe pr√ºfen, ob es in dieser Whitelist enthalten ist.
        //     * Wende dann auf diesen bereinigten String die strikte Logik zur abwechselnden Gro√ü-/Kleinschreibung aus Teil (b) an: Zeichen an geraden Indizes werden zu Gro√übuchstaben, Zeichen an ungeraden Indizes zu Kleinbuchstaben.
        //     * Zeige den endg√ºltig modifizierten String an.
        
        // ---
        
        // ### Grundlegende Datenkompression (Konzeptionell) ü§è
        
        // Bei dieser √úbung geht es mehr darum, einen Prozess zu durchdenken. Stelle dir vor, du m√ºsstest eine einfache Form der Datenkompression implementieren, die als Laufl√§ngenkodierung (Run-Length Encoding, RLE) bezeichnet wird.
        
        // **Was ist Laufl√§ngenkodierung (RLE)?**
        // Die Laufl√§ngenkodierung ist eine einfache Form der Datenkompression, bei der Sequenzen von gleichen Datenwerten (sogenannte "Runs" oder "L√§ufe") als ein einzelner Datenwert und dessen Anzahl gespeichert werden. Sie ist besonders effektiv bei Daten mit vielen Wiederholungen.
        
        // * **Beispiel f√ºr Kodierung mit Bin√§rcode (einzelne Bits)**: Ein Bin√§rstring wie `0000011100000000` (16 Bit) besteht aus:
        //     * F√ºnf `0`en
        //     * Drei `1`en
        //     * Acht `0`en
        //     Die RLE-Version k√∂nnte dann als Sequenz von (Anzahl, Wert) Paaren dargestellt werden, z.B. `(5,0)(3,1)(8,0)` oder in einer kompakteren Form wie `503180`.
        
        // * **Beispiel f√ºr Dekodierung mit Bin√§rcode (einzelne Bits)**: Aus der RLE-Darstellung `503180` w√ºrde man wieder den urspr√ºnglichen Bin√§rstring `0000011100000000` erhalten.
        
        // * **Anwendungsbeispiel: Bilddaten (Pixelwerte)** üñºÔ∏è
        //     Stell dir eine Bilddatei vor. Jedes Pixel wird oft durch drei Farbwerte dargestellt: Rot, Gr√ºn und Blau (RGB). Jeder dieser Werte kann z.B. 1 Byte (8 Bit) beanspruchen, also insgesamt 3 Bytes pro Pixel. Ein Pixel mit der Farbe Wei√ü k√∂nnte z.B. als (255, 255, 255) gespeichert werden, was bin√§r `11111111 11111111 11111111` (3 Bytes) entspricht.
        //     Wenn nun mehrere aufeinanderfolgende Pixel exakt denselben Farbwert haben (also dieselben 3 Bytes), kann RLE angewendet werden:
        //     * **Originale Pixeldaten (Sequenz von 3-Byte-Farbwerten):**
        //         `Pixel1_RGB_Daten` `Pixel1_RGB_Daten` `Pixel1_RGB_Daten` `Pixel2_RGB_Daten` `Pixel2_RGB_Daten`
        //         (Wobei `Pixel1_RGB_Daten` z.B. die 3 Bytes f√ºr Wei√ü sind, und `Pixel2_RGB_Daten` die 3 Bytes f√ºr eine andere Farbe.)
        //     * **RLE-kodiert:** `(3, Pixel1_RGB_Daten) (2, Pixel2_RGB_Daten)`
        //     Dies speichert, dass der 3-Byte-Block `Pixel1_RGB_Daten` dreimal vorkommt, gefolgt von zweimal dem 3-Byte-Block `Pixel2_RGB_Daten`. Dies ist besonders bei gro√üen, einfarbigen Fl√§chen in Bildern effizient.
        
        // **Aufgabe**:
        
        // 1.  Beschreibe in Worten (Pseudocode oder eine schrittweise Beschreibung) die Logik, die du verwenden w√ºrdest, um eine Java-Methode `String komprimiere(String eingabe)` zu schreiben, die eine RLE-Kodierung f√ºr einen String durchf√ºhrt, der nur aus den Zeichen '0' und '1' besteht (√§hnlich dem ersten Bin√§rcode-Beispiel, das einzelne Bits/Zeichen komprimiert).
        // 2.  Beschreibe in Worten die Logik f√ºr eine Methode `String dekomprimiere(String komprimierteEingabe)`, die die entsprechende Dekodierung f√ºr den RLE-kodierten '0'/'1'-String durchf√ºhrt.
        
        // *Du musst f√ºr diese √úbung nicht den vollst√§ndigen Java-Code schreiben, sondern dich auf die algorithmischen Schritte konzentrieren.*
        
        // ---

        // ### Ist es ein Palindrom?
        // Das bedeutet, dass das Wort von vorne und von hinten gelesen den gleichen Text ergibt.
        // Wir m√ºssen also:
        // - (um ganz genau zu sein, alle Leerzeichen entfernen und alles in Kleinbuchstaben umwandeln)
        // - das Wort umdrehen
        // - vergleichen, ob es mit dem nicht umgedrehten √ºbereinstimmt.
        // Wenn ja, dann ist es ein Palindrom, ansonsten nicht.
        
        // ### Anagramm-Ermittler üïµÔ∏è‚Äç‚ôÄÔ∏è
        
        // Zwei Strings sind Anagramme, wenn sie dieselben Zeichen in derselben Anzahl enthalten, aber m√∂glicherweise in einer anderen Reihenfolge (z.B. "listen" und "silent", oder "Tom Marvolo Riddle" und "Ich bin Lord Voldemort" nach der Normalisierung).
        
        // Schreibe ein Java-Programm, das:
        
        // 1.  Den Benutzer zur Eingabe von zwei Strings auffordert.
        // 2.  Beide Strings vorverarbeitet:
        //     * Alle Leerzeichen entfernt.
        //     * Alle Zeichen in eine einheitliche Schreibweise umwandelt (z.B. Kleinbuchstaben).
        // 3.  Ermittelt, ob die beiden vorverarbeiteten Strings Anagramme voneinander sind.
        //     * **Hinweis**: √úberlege, wie du den Zeicheninhalt zweier Strings unabh√§ngig von ihrer Reihenfolge vergleichen kannst. Das Sortieren der Zeichen jedes Strings k√∂nnte ein hilfreicher Ansatz sein.
        // 4.  Ausgibt, ob die beiden urspr√ºnglichen Strings (nach der Normalisierung) Anagramme sind.
        


    }
}