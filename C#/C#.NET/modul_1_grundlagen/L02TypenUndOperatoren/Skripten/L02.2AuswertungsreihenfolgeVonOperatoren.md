# Auswertungsreihenfolgen von Operatoren
Die ersten √úberschriften erinnern an einen Mathematikunterricht. Wir m√ºssen uns jedoch einmal mit der ``Auswertungsreihenfolge`` von ``Operatoren`` besch√§ftigen und starten deshalb ein wenig trocken.

**Anmekrung:** Diese Einf√ºhrung ist nicht ausreichend um korrekte ``Terme`` im allgemeinen schreiben zu k√∂nnen. Wir stellen hier nur das n√∂tigste dar um ``logische Ausdr√ºcke`` darstellen zu k√∂nnen.

## Was sind Operatoren?
Wir merken uns:
>Operatoren verkn√ºpfen ``Variablen`` und ``Werte`` miteinander und erzeugen basierend auf diesen einen neuen ``Wert``.

Der folgende *+* ``Operator``, welcher die Bedeutung *"Addition"* hat, verkn√ºpft die Zahlen *35* und *17* und erzeugt einen neuen ``Wert`` *52*:

```csharp
Console.WriteLine(35 + 17); // 52
```

Die Bedeutung eines ``Operators`` ist abh√§ngig vom ``Typ`` der ``Variablen`` bzw. ``Werte``, welche in den ``Operator`` "hineingegeben" werden. Das sehen wir bei dem Ausdruck *"35" + "17"*. Hier hat der Operator *+* nicht die Bedeutung der *"Addition"*, sondern der *"Concatenation"* (zusammenf√ºgen). Wir f√ºgen also die Zeichenkette *"35"* mit der Zeichenkette *"17"* zusammen, was *"3517"* ergibt. Die gew√ºnschte ``Operation`` (*Addition* oder *Concatenation*) ist somit nicht nur vom Symbol des ``Operators`` definiert. Wir nennen ``Operatoren`` welche kein eindeutiges Symbol besitzten ``√ºberladene Operatoren``.

```csharp
Console.WriteLine("35" + "17") // "3517"
```

Das gleiche Verhalten gilt f√ºr ``Variablen``:

```csharp
int firstInt = 35;
int secondInt = 17;
int thirdInt = 25;
int fourthInt = 47;

Console.WriteLine(firstInt + secondInt);
Console.WriteLine(firstInt + 17);

string first_string = "35";
string second_string = "17";

Console.WriteLine(first_string + second_string);
Console.WriteLine("35" + second_string);
```

Wir gehen sp√§ter mit Beispielen auf die so genannte ``√úberladung`` der ``Operatoren`` ein. Wir merken uns jedoch:
>Der Aufruf der gew√ºnschten ``Operation`` ist nicht eindeutig durch den ``Operator`` bestimmt. Die ``Typen`` der ``Werte`` bzw. ``Variablen`` welche in den ``Operator`` flie√üen entscheiden dies bei ``√ºberladenen Operatoren``.

## Wie werden mehrere gleiche Operatoren ausgewertet?
Wir beginnen zuerst mit ``Ausdr√ºcken``, welche nur eine Art von ``Operatoren`` verwenden. Wir nennen das kurz "``Ausdr√ºcke`` mit gleichen" ``Operatoren``.

Ein Aufruf eines ``Operators`` erzeugt einen  ``Wert`` mit einem ``Typ``. Dieser ``Wert`` kann direkt mit einem ``Operator`` und z.B. einen anderen ``Wert`` verkn√ºpft werden kann. Es kann also eine Art "Kette" gebildet werden.

```
Console.WriteLine(firstInt + secondInt + thirdInt + fourthInt) // 124
```

Wir betrachten nun die ``Auswertungsreihenfolge`` unserers gerade geschriebenen ``Ausdrucks``:
1. Suche den linkesten ``Operator``
2. Zuerst wir der links stehende Ausdruck vom ``Operator`` verarbeitet.
3. Dann der rechts stehende Ausdruck vom ``Operator``.
4. Der neu erzeugte ``Wert`` ersetzt den Ausdruck links, rechts und den ``Operator``. 
5. gehe zu 1. - Es wird wiederholt bis nur mehr ein ``Wert`` √ºbrig ist. Dieser ist unser ``Ergebnis``.

**Anmerkung:** Wir m√ºssen die gerade geschriebene Aufz√§hlung noch anpassen wenn wir Klammern und verschiedene ``Operatoren`` verwenden. Diese Aufz√§hlung ist also nur **vorl√§ufig** und nicht final!

Bestimmen wir die ``Auswertungsreihenfolge`` des vorherigen ``Ausdrucks``.
1. : Das *+* zwischen *firstInt* und *secondInt* ist das linkeste.

2. , 3. und 4.: *+* erzeugt einen neuen ``Wert`` aus *firstInt* und *secondInt*. Diser ist *52*. *52* Ersetzt den Ausdruck ``firstInt + secondInt``.
```csharp
Console.WriteLine(52 + thirdInt + fourthInt);
```

5. und 1.: ich gehe zu **1.**  und suche den linkesten ``Operator``. Dieser ist das *+* zwischen *52* und *thirdInt*
```csharp
Console.WriteLine(52 + thirdInt + fourthInt);
```

2. , 3. und 4.: *+* erzeugt einen neuen ``Wert`` aus *52* und *thirdInt*. Diser ist *77*. *77* Ersetzt den Ausdruck ``52 + thirdInt``.
```csharp
Console.WriteLine(77 + fourthInt);
```

5. und 1.: ich gehe zu **1.**  und suche den linkesten ``Operator``. Dieser ist das *+* zwischen *77* und *fourthInt*
```csharp
Console.WriteLine(77 + fourthInt);
```

2. , 3. und 4.: *+* erzeugt einen neuen ``Wert`` aus *77* und *fourthInt*. Diser ist *124*. *124* Ersetzt den Ausdruck ``77 + fourthInt``.
```csharp
Console.WriteLine(124);
```

5. : Es wird wiederholt bis nur mehr ein ``Wert`` √ºbrig ist. *124* ist somit unser ``Ergebnis``.

Wir merken uns:
> ``Ausdr√ºcke`` gleicher ``Operatoren`` werden von *links* nach *rechts* aufgel√∂st. Den letzten ``Wert`` welche der ``Ausdruck`` erzeugt wird ``Ergebnis`` des ``Ausdrucks`` genannt. 

### Ist die Auswertungsreihenfolge bei gleichen Operatoren wichtig?
Obwohl wir die ``Auswertungsreihenfolge`` beider ``Ausdr√ºcke`` √§ndern, √§ndert sich das ``Ergebnis`` nicht.

```csharp
Console.WriteLine(firstInt + secondInt + thirdInt + fourthInt); // 124
Console.WriteLine(fourthInt + firstInt + thirdInt + secondInt); // 124
```

Die meisten ``Operatoren`` sind jedoch nicht so angenehm wie das hier verwendete **+**. Tausche nun *+* mit *-* aus. Bleibt das ``Ergebnis`` wieder gleich?

```csharp
Console.WriteLine(firstInt - secondInt - thirdInt - fourthInt); // -54
Console.WriteLine(fourthInt - firstInt  - secondInt - thirdInt); // -30
```

Nein. Es ist nun unterschiedlich. Wir gehen jedoch nicht n√§her auf dieses Verhalten ein und verweisen auf den Mathematik Kurs und die Konzepte ``assoziativ`` und ``kommutativ``. Jedoch merken wir uns:
> Wenn **nur** gleiche ``Operatoren`` vorkommen, ist die ``Auswertungsreihenfolge`` bei der *Addition* **+** und *Multiplikation* __*__ **nicht wichtig**.

> Wenn **nur** gleiche ``Operatoren`` vorkommen, ist die ``Auswertungsreihenfolge`` bei der *Subtraktion* **-** und *Division* __/__ **wichtig**.

Wichtig bedeutet hier das ``Ergebnis`` √§ndert sich.

### Wie steuern wir die Auswertungsreihenfolge bei gleichen Operatoren?
Wenn wir die Reihenfolge der Auswertung steuern wollen, *ohne die ``Werte`` zu vertauschen*, muss dies mit einer *Klammer* gemacht werden. Der n√§chste Ausdruck hat die gleiche Auswertungsreihenvolge wie jener aus der [vorherigen](#ist-die-reihenfolge-der-variablen-bei-gleichen-operatoren-wichtig) √úberschrift. Jedoch wird von uns hier die ``Auswertungsreihenfolge`` direkt durch *Klammern* angegeben. 

```csharp
Console.WriteLine(((firstInt - secondInt) - thirdInt) - fourthInt); // -54
```

Wie bestimmen wir nun die ``Auswertungsreihenfolge``? Beginnen wir diesmal zuf√§llig und starten **nicht** links:
1. Suche einen beliebigen ``Operator`` und betrachte die ``Werte`` links und rechts davon.
2. Wenn einer der beiden ``Werte`` eine ``Klammer`` besitzt, gehe in diese ``Klammer`` hinein und starte bei der linkesten ``Operation``.
    1. Wiederhole bis **3.** passiert.
3. Ansonsten, wenn beiden ``Werte`` keine ``Klammern`` besitzen, f√ºhre die ``Operation`` durch, erzeuge einen neuen ``Wert`` und entferne die ``Klammer``, falls vorhanden.
    1. Wiederhole bis **2.** passiert, **oder** keine ``Klammern`` mehr vorhanden sind, **oder** nur mehr ein ``Wert`` √ºbrig ist. Das ist unser ``Ergebnis``. Falls keine ``Klammern`` mehr vorhanden sind, werte von links nach rechts aus.

**Anmerkung:** Wir m√ºssen die gerade geschriebene Aufz√§hlung noch anpassen wenn wir verschiedene ``Operatoren`` verwenden. Diese Aufz√§hlung ist also nur **vorl√§ufig** und nicht final!

Bestimmen wir nun die ``Auswertungsreihenfolge`` des vorherigen ``Ausdrucks``.
```csharp
Console.WriteLine(((firstInt - secondInt) - thirdInt) - fourthInt); // -54
```
1. : Durch Zufall haben wir das *-* zwischen *thirdInt* und der ``Klammer`` gew√§hlt.

2. : Da die linke ``Variable`` eine ``Klammer`` besitzt, gehen wir in diese hinein. 

3. : Da innerhalb dieser ``Klammer`` beide ``Werte`` **keine** ``Klammer`` besitzen, f√ºhre die ``Operation`` durch und...
```csharp
Console.WriteLine((-7) - fourthInt);
```
... entferne die ``Klammer``.
```csharp
Console.WriteLine(-7 - fourthInt);
```

3. : Da innerhalb dieser ``Klammer`` beide ``Werte`` **keine** ``Klammer`` besitzen, f√ºhre die ``Operation`` durch.
```csharp
Console.WriteLine(-54);
```
Da nur mehr ein ``Wert`` √ºbrig ist, ist unser ``Ergebnis`` *-54*.

Wir merken uns:
> Die ``Auswertungsreihenfolge`` von ``Ausdr√ºcke`` gleicher ``Operatoren`` mit ``Klammern``, ist durch die ``Klammerung`` vorgegeben. 

> Die letzte ``Operation`` welche durchgef√ºhrt wird, wird ``letzauszuf√ºhrende Operation`` genannt. Diese ist besonders wichtig f√ºr den Umgang von ``logischen Ausdr√ºcken``.

Wir k√∂nnen nun die ``Auswertungsreihenfolge`` √§ndern, indem wir die ``Klammern`` nach unserem Ermessen setzten. Bestimmen wir die ``Auswertungsreihenfolge`` des folgenden ``Ausdrucks``.

```csharp
Console.WriteLine(firstInt - (secondInt - thirdInt) - fourthInt);
```

1. : Durch Zufall haben wir das *-* zwischen *firstInt* und der ``Klammer`` gew√§hlt.

2. : Da die rechte ``Variable`` eine ``Klammer`` besitzt, gehen wir in diese hinein. 

3. : Da innerhalb dieser ``Klammer`` beide ``Werte`` **keine** ``Klammer`` besitzen, f√ºhre die ``Operation`` durch und...
```csharp
Console.WriteLine(firstInt - (-8) - fourthInt);
```
... entferne die ``Klammer``.
```csharp
Console.WriteLine(firstInt - -8 - fourthInt);
```

3. : Da keine ``Klammern`` mehr vorhanden sind, werte von links nach rechts aus.
```csharp
Console.WriteLine(43 - fourthInt);
```

3. : Da keine ``Klammern`` mehr vorhanden sind, werte von links nach rechts aus.
```csharp
Console.WriteLine(-4);
```

## Wie werden mehrere verschiedene Operatoren ausgewertet?
Wir verzichten nun auf die Verwenung von gleichen ``Operatoren`` in einem ``Ausdruck``. Die bis jetzt ausgef√ºhrten Gedankenspiele werden nun ben√∂tigt, da wir nun verschiedene ``Operatoren`` in einem ``Ausdruck`` zulassen. Wir haben hier 2 M√∂glichkeiten. Entweder, wir verwenden f√ºr jede ``Operation`` eine ``Klammer``, oder f√ºhren eine ``Auswertungsreihenfolge`` bedingt auf die benachbarten ``Operatoren`` ein.

Da die Verwendung von ``Klammern`` in jedem Schritt unleserliche ``Ausdr√ºcke`` erzeugt, f√ºhren wir eine ``Auswertungsreihenfolge`` ein. Von der Schule ist vl. noch der Ausdruck **KlaPuStri** bekannt. Dieser soll die St√§rke der Bindung zwischen ``Operatoren`` ausdr√ºcken.
1) Klammern binden am st√§rksten unabh√§ngig von den benachbarten ``Operatoren``
2) ``Punkt-Operatoren`` (*, /) binden st√§rker als nicht ``Strich-Operatoren`` (+, -)
3) ``Strich-Operatoren`` binden am schw√§chsten

Da wir jedoch nun eine gr√∂√üere Anzahl an ``Operatoren`` besitzen welche kombiniert werden k√∂nnen, m√ºssen wir diese Aufz√§hlung anpassen.
Wir merken uns:
>1) Klammern binden am st√§rksten unabh√§ngig von den benachbarten ``Operatoren``
>2) innerhalb von ``arithmetischen Operatoren`` gilt:
>    1) ``Punkt-Operatoren`` (*, /, %) binden strker als nicht ``Strich-Operatoren`` (+, -)
>    2) ``Strich-Operatoren`` binden am schw√§chsten
>3) ``arithmetische Operatoren`` binden st√§rker als ``Vergleichsoperatoren`` (``<, >, <=, >=, ==, !=, in, not in, is, is not``). Innerhalb dieser gilt:
>    1) Alle sind gleichwertig, deshalb ist die ``Auswertungsreihenfolge`` innerhalb dieser links nach rechts.
>4) ``Vergleichsoperatoren`` binden st√§rker als der ``Zuweisungs Operator`` (``=``)
>5) Der ``Zuweisungs Operator`` bindet st√§rker als ``logische Operatoren`` (``!, &&, ||``). Innerhalb dieser gilt:
>    1) ``!`` bindet am st√§rksten
>    2) ``&&`` bindet st√§rker als ``||``
>    3) ``||`` bindet am schw√§chsten.

Es k√∂nnte somit der Begriff **KlaPuStriVerZuNotAndOr** oder **ArVerZuLo** erzeugt werden. Diese scheinen jedoch begrenzt sinnvoll zu sein.

Bestimmen wir nun die ``Auswertungsreihenfolge`` von ``Ausdr√ºcke`` welche verschiedene ``Operatoren`` zulassen. Dazu passen wir unsere Regeln entsprechend an:
Wir merken uns:
>0. Setze eine Klammer-auf ganz *links* und eine Klammer-zu ganz *rechts* um den ``Ausdruck``.
>1. Verwende die linkeste ``Variable`` oder ``Wert`` und betrachte dessen ``Operator``. Betrachte nun die ``Werte`` links und rechts dieses ``Operators``.
>2. Wenn einer der beiden ``Werte`` des ``Operators`` eine ``Klammer`` besitzt, gehe in diese ``Klammer`` hinein und starte bei der linkesten ``Operation``.
>    1. Wiederhole bis **3.** passiert.
>3. Ansonsten, ber√ºcksichtige alle ``Operatoren`` innerhalb der ``Klammer`` ohne eine **weitere** ``Klammer`` zu √∂ffnen. F√ºre jene ``Operation`` durch welche am st√§rksten bindet und erzeuge einen neuen ``Wert``. Entferne die ``Klammer`` falls die ``Operation`` die letzte innerhalb dieser war. Falls die ``Klammer`` entfernt wurde, ber√ºcksichtige alle ``Operatoren`` innerhalb der neuen ``Klammer``. W√§hle den st√§rkst bindenden ``Operator``.
>    1. Wiederhole bis **2.** passiert **oder** nur mehr ein ``Wert`` √ºbrig ist. Das ist unser ``Ergebnis``.

Betrachten folgendes komplexes Beispiel.
```csharp
Console.WriteLine(!(firstInt + (secondInt - thirdInt) * fourthInt > 85 && (fourthInt = fourthInt + 5) != 10)); // ü§î
```

1. : Die linkeste ``Variable`` oder ``Wert`` ist *firstInt*.

2. : Da einer der ``Werte`` der ``Operation`` eine ``Klammer`` besitzt, springen wir in diese ``Klammer``.

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische Operation`` **-** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen. Wir entfernen die ``Klammer``, da die letzte ``Operation`` innerhalb dieser ausgewertet wurde und ber√ºcksichtigen die neue ``Klammer``.
```csharp
Console.WriteLine(!(firstInt + -8 * fourthInt > 85 && (fourthInt = fourthInt + 5) != 10));
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische Operation`` __*__ ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```csharp
Console.WriteLine(!(firstInt + -376 > 85 && (fourthInt = fourthInt + 5) != 10));
;```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische Operation`` **+** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```csharp
Console.WriteLine(!(-341 > 85 && (fourthInt = fourthInt + 5) != 10));
;```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Vergleichsoperation`` **>** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```csharp
Console.WriteLine(!(False && (fourthInt = fourthInt + 5) != 10));
```

**Anmerkung:** Hier wird bereits eine sogenannte ``minimal evaluation`` durchgef√ºhrt. Diese kann verwendet werden, wenn die ``letzauszuf√ºhrende Operation`` eine bin√§re ``logische Operation`` ist. Da wir ein logisches UND mit einem ``False`` Wert haben, k√∂nnen wir bereits den ``Ausdruck`` auf ``false`` auswerten. **Das ist hier dramatisch!** Denn wir haben eine Zuweisung auf der rechten Seite des logischen UNDs, welche damit nicht ausgef√ºhrt wird. Dehalb ist es nicht √ºblich Zuweisungen ``=`` in Verbindung mit ``logischen Ausdr√ºcken`` zu verwenden.

2. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Vergleichsoperation`` **!=** ist und einer der ``Werte`` der ``Operation`` eine ``Klammer`` besitzt, springen wir in diese ``Klammer``.

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische operation`` **+** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```csharp
Console.WriteLine(!(False && (fourthInt = 52) != 10));
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Zuweisungsoperation`` **=** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen. Wir entfernen die ``Klammer``, da die letzte ``Operation`` innerhalb dieser ausgewertet wurde und ber√ºcksichtigen die neue ``Klammer``.
```csharp
Console.WriteLine(!(False && 52 != 10));
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Vergleichsoperation`` **!=** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen. 
```csharp
Console.WriteLine(!(False && True));
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``logische Operation`` **&&** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```csharp
Console.WriteLine(!(False));
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``logische Operation`` **!** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```csharp
Console.WriteLine(True);
```