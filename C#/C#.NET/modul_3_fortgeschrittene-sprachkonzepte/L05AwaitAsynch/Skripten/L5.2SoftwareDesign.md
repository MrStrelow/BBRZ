*weiterführende Info:*
    * Ein ``IReposiotry`` ist ein einheitliche Schnittstelle (meist ein ``Interface``) welches ``C.R.U.D`` und "kompliziertere" ``Abfragen`` (z.B. "Was ist unser meistverkauftes Produkt im Jahr 2015 bis 2025 pro Konsumenten-Gruppen?") bereistellt.
    * Ein ``Service`` ist eine ``Klasse`` welche die ``Business-Logik`` umsetzt. Diese Logik kümmert sich um das Verhalten von z.B. einer ``Entity`` und verwendet ``Repositories``, ``DTOs`` und andere ``Services`` um *wichitge* Probleme zu lösen.
    * Wir erinnern uns, dass wir folgende `Daumenregel` anwenden:
        * Wir designen eine ``Entity`` mit einem ``UML`` Klassendiagramm. z.B. ein ``User.`` und "packen dort alles rein" was uns einfällt.
        * Anschließend "zerreißen" wir diese ``Entity``. Dadurch entstehten:
            * ``Services`` z.B. ``KundenService`` wo ``Methoden`` für die ``Business-Logik`` sind
            * ``Repositories`` z.B. ``KundenRepository`` wo ``Methoden`` für die ``Datenbank`` sind.
            * ``DTOs`` z.B. ``KundenDTO`` welches eine maßgeschneidertes Hülle zur Datenübertragen ist. *Daumenregel*: Ein ``DTO`` ist wie eine ``Entity`` für Datenübertragung, nicht für die Datenbank.
            * ``Controller`` z.B. ``KundenController`` sind die ``Endpoints`` der ``HTTP-Methoden`` und rufen ``Services`` auf (nicht hier behandelt, aber in dem Fach Web-Programmieren)
            * ``View`` z.B. Details.cshtml und Index.cshtml welche sich zusammen um die Darstellung der ``Entity`` Kunde auf der Website kümmern und ein ``ViewModel`` welche kompliziertere serverseitige ``Darstellungs-Logik`` enthält (nicht hier behandelt, aber in dem Fach Web-Programmieren)
            * ``Test`` z.B. ein ``KundenTest`` welcher einzelne ``Methoden`` aus ``Services``, ``Repositories`` und ``Views`` isoliert testet (``Unit Tests``). 
        * **Wichtig!** Nun überlegen wir uns ob wir all diese Dinge für die ``Entity`` *Kunde* brauchen und entfernen, was nicht unsren Anforderungen entspricht. Dazu müssen wir auch alle anderen ``Entities`` berücksichtigen, die uns eingefallen sind. Es können nun auch z.B. ``Services`` entstehen die eine *Kombination* aus ``Entities`` sind. Wie ein ``Service`` *VerkaufsService*, welche sich um die ``Entities`` *Kunde*, *Shop*, *Leiferant* usw. kümmert. ``Tests`` sind hier besondes stark betroffen, denn es gibt eine Vielzahl von konzeptionellen ``Software Tests``, welche in einem eigenen Fach behandelt werden. Diese reichen von isoliertem Testen einer ``Methoden`` (``Unit Test``), zum Testen wie verschiedene ``Services`` mit ``Repositories`` interagieren (``Integration Tests``) und eine gesamte ``User Journey`` gestartet vom login bis zum Abschluss eines Produktkaufs abbildet (``End-to-End Tests``) 