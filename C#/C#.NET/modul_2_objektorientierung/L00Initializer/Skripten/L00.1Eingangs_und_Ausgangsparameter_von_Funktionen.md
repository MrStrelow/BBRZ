## Spezielle Handhabung von Eingangs- und Rückgabeparameter

### Optionale Parameter
Optionale Parameter erhöhen die Flexibilität von Methoden, indem sie es dem Aufrufer erlauben, bestimmte Argumente wegzulassen. Ein Parameter wird optional, indem ihm in der Methodensignatur ein Standardwert zugewiesen wird. Alle optionalen Parameter müssen **nach** den erforderlichen (nicht-optionalen) Parametern definiert werden.

Man kann optionale Parameter weglassen, positionell angeben oder über ihren Namen ansprechen. Die Kombination mit benannten Argumenten ist besonders mächtig, da man so spezifische optionale Parameter überschreiben kann, ohne die davor liegenden ebenfalls angeben zu müssen.

```csharp
// 'subject' und 'isHighPriority' sind optionale Parameter
public void SendEmail(string recipient, string body, string subject = "No Subject", bool isHighPriority = false)
{
    Console.WriteLine($"Sending to: {recipient}");
    Console.WriteLine($"Subject: {subject}");
    Console.WriteLine($"Body: {body}");
    Console.WriteLine($"High Priority: {isHighPriority}");
    Console.WriteLine("---");
}

// 1. Aufruf nur mit den erforderlichen Parametern
// 'subject' und 'isHighPriority' nehmen ihre Standardwerte an.
SendEmail("test@example.com", "This is the body.");

// 2. Aufruf mit einem optionalen Parameter
// 'subject' wird überschrieben, 'isHighPriority' bleibt Standard.
SendEmail("test@example.com", "Another body.", "Important Update");
```
### Named vs. Positional Arguments
Es können Methodenparameter auf zwei Arten übergeben werden: über ihre Position oder über ihren Namen.

* **Positional Arguments**: Dies ist die Standardmethode. Die Argumente müssen in der exakten Reihenfolge übergeben werden, in der die Parameter in der Methodensignatur definiert sind. Dies ist bei Methoden mit wenigen, eindeutigen Parametern (z.B. `int Sum(int a, int b)`) unproblematisch. Bei Methoden mit vielen Parametern, insbesondere vom gleichen Typ, wird es schnell unleserlich und fehleranfällig.

* **Named Arguments**: Hier wird der Name des Parameters explizit angegeben, gefolgt von einem Doppelpunkt und dem Wert (`parameterName: value`). Dies erhöht die Lesbarkeit des Codes erheblich, da die Absicht jedes Arguments sofort klar ist. Ein weiterer Vorteil ist, dass die Reihenfolge der Argumente irrelevant wird. Man kann sie beliebig anordnen, was besonders bei optionalen Parametern nützlich ist.

```csharp
// Eine Methode mit vielen, teils optionalen, Parametern
public void GenerateReport(string reportName, bool includeHeader, bool includeFooter, string author = "System", int resolutionDpi = 300)
{
    Console.WriteLine($"Generating Report: '{reportName}'");
    Console.WriteLine($"Author: {author}, Resolution: {resolutionDpi} DPI");
    Console.WriteLine($"Header included: {includeHeader}, Footer included: {includeFooter}");
}

// 1. Aufruf mit Positional Arguments
// Unübersichtlich: Was bedeuten 'true, true'? Man muss die Methodendefinition nachschlagen.
GenerateReport("MonthlySales", true, true, "John Doe");

// 2. Aufruf mit Named Arguments
// Viel klarer und selbst-dokumentierend. Die Reihenfolge ist egal.
GenerateReport(
    includeFooter: true, 
    reportName: "AnnualReview", 
    includeHeader: true, 
    resolutionDpi: 600
); // Der optionale 'author' Parameter wird weggelassen und nimmt seinen Standardwert "System". Das geht nur mit Named Arguments in Kombination mit Optionalen Parametern!
```

### Das `params` Keyword
Das `params`-Schlüsselwort ermöglicht es einer Methode, eine variable Anzahl von Argumenten desselben Typs zu akzeptieren. Es ist syntaktischer Zucker, der es dem Aufrufer erspart, explizit ein Array erstellen und übergeben zu müssen. Collections im allgemein funktionieren nicht.

**Wichtige Regeln:**
1.  Es kann nur **ein** `params`-Parameter pro Methode geben.
2.  Der `params`-Parameter muss der **letzte** Parameter in der Methodensignatur sein.

```csharp
// Die Methode kann andere fixe Parameter vor dem params-Parameter haben.
public void LogEntries(string category, params string[] messages)
{
    Console.WriteLine($"--- Log Category: {category} ---");
    if (messages.Length == 0)
    {
        Console.WriteLine("No messages provided.");
        return;
    }

    for (int i = 0; i < messages.Length; i++)
    {
        Console.WriteLine($"Message {i + 1}: {messages[i]}");
    }
}

// Verschiedene Aufrufe:
LogEntries("ERROR", "Database connection failed.", "Retrying in 5 seconds.");
LogEntries("INFO", "User logged in successfully.");
LogEntries("WARN"); // Auch ein Aufruf ohne params-Argumente ist gültig (leeres Array).

// Man kann auch explizit ein Array übergeben
string[] criticalErrors = { "Out of memory", "Disk full" };
LogEntries("CRITICAL", criticalErrors);
```

### Rückgabeparameter aufteilen mit Tuples
Vor C# 7.0 war die Rückgabe mehrerer Werte aus einer Methode umständlich. Übliche Ansätze waren:
* **`out`-Parameter**: Funktional, aber oft unhandlich im Aufruf und nicht für async-Methoden geeignet.
* **Eigene `class` oder `struct`**: Viel Boilerplate-Code für eine einfache Datenstruktur.
* **`System.Tuple<T1, T2, ...>`**: Unhandlicher Zugriff über Properties wie `Item1`, `Item2`, was den Code schwer lesbar macht.

**ValueTuples** (eingeführt in C# 7.0) lösen dieses Problem elegant. Sie sind leichtgewichtige `structs`, die es erlauben, benannte Elemente zurückzugeben (structs lernen wir später noch kennen).

#### Tuple anlegen
Wir schreiben für ein Tuple folgendes
```csharp
var meinUnbekanntesTuple = (1,"ok",563);
var meinBekanntesTuple = (id: 1, status: "ok", anzahl: 563);

public (bool success, double latitude, double longitude) ParseCoordinates(string input) 
{ 
    int id = ;
    string status = "ok"
    ...

    return (id, status, 563);
}

var myTuple = ParseCoordinates("48.2082, 16.3738");
Console.Write(myTuple.status);
```

#### Out Keyword 
Erinnere dich an das ``Keyword`` ``out``, welches ``Parameter`` als ``call by reference`` übergibt.
Wir können hier ``call by reference`` verwende, um mehrere ``Rückgabeparameter`` zurcükgeben zu können.
```csharp
// Klassischer Ansatz mit 'out'
public bool TryParseCoordinates(string input, out double latitude, out double longitude)
{
    latitude = 0;
    longitude = 0;
    string[] parts = input.Split(',');
    if (parts.Length != 2) return false;
    
    bool latParsed = double.TryParse(parts[0], out latitude);
    bool lonParsed = double.TryParse(parts[1], out longitude);
    
    return latParsed && lonParsed;
}


// Anderer Ansatz mit einem benannten Tuple
// Die Rückgabe beschreibt sich selbst: Entweder man bekommt die Koordinaten oder einen Fehler.
public (bool success, double latitude, double longitude) ParseCoordinates(string input)
{
    string[] parts = input.Split(',');
    if (parts.Length != 2)
    {
        return (false, 0, 0); // Fehlerfall zurückgeben
    }

    bool latParsed = double.TryParse(parts[0], out var lat);
    bool lonParsed = double.TryParse(parts[1], out var lon);

    if (latParsed && lonParsed)
    {
        return (true, lat, lon); // Erfolgsfall mit Werten zurückgeben
    }
    
    return (false, 0, 0); // Fehlerfall zurückgeben - Nachteil, es muss immer ein ganzes Tuple zurückgegeben werden, auch wenn Teile dieses Tuples fehlen.
}

// Aufruf und "Deconstruction" des Tuples
// alt
var tuple = ParseCoordinates("48.2082, 16.3738");
if (tuple.success)
{
    Console.WriteLine($"Latitude: {tuple.latitude}, Longitude: {tuple.longitude}");
}
else
{
    Console.WriteLine("Ungültiges Format.");
}

// Split des Rückgabeparameters - wir können hier einfach neue namen vergeben - aus longitude wurde lon
var (wasSuccessful, lat, lon) = ParseCoordinates("48.2082, 16.3738");
if (wasSuccessful)
{
    Console.WriteLine($"Latitude: {lat}, Longitude: {lon}");
}
else
{
    Console.WriteLine("Ungültiges Format.");
}
```