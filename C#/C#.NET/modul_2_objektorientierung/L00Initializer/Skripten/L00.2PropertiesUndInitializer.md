## Properties und Initializer

Properties sind das Kernstück der **Kapselung** in C#. Sie agieren als Vermittler (Mediatoren) zwischen dem internen Zustand eines Objekts (seinen privaten Feldern) und der Außenwelt.

### Properties vs. Fields

* **Fields** (Felder) sind reine Datenspeicher. Sie sollten fast immer `private` sein, um den direkten, unkontrollierten Zugriff von außen zu verhindern. Wenn ein Feld `public` ist, verliert die Klasse die Kontrolle darüber, welche Werte ihr zugewiesen werden. Man spricht von einem "leaky abstraction" (undichten Abstraktion).

* **Properties** (Eigenschaften) definieren einen kontrollierten Zugriff auf die Daten. Sie sehen von außen wie Felder aus, sind aber intern Methoden (`get_` und `set_`). Dadurch kann man Logik ausführen, wenn ein Wert gelesen oder geschrieben wird, z.B. zur Validierung, Berechnung oder zum Auslösen von Events.

```csharp
public class Employee
{
    // Schlechtes Design: Direkter Zugriff auf das Feld.
    // - Kein Schutz vor ungültigen Werten (z.B. negativer Lohn).
    // - Keine Benachrichtigung bei Änderung.
    public double _salary;

    // Gutes Design: Gekapseltes Feld mit Property.
    private string _name; // Backing Field

    public string Name
    {
        get 
        { 
            // Hier könnte man z.B. den Zugriff loggen.
            return _name;
        }
        set 
        {
            // Guard-Clause zur Validierung.
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Der Name darf nicht leer sein.");
            }
            _name = value.Trim(); // Zusätzliche Logik: Whitespace entfernen.
        }
    }

    // Auto-implementierte Property: Der Compiler generiert das private Backing Field im Hintergrund.
    // Ideal, wenn keine zusätzliche Logik benötigt wird.
    public int Id { get; set; }
}
```

### Die Notwendigkeit von Backing Fields und das `field`-Keyword in C#

Wenn wir Eigenschaften (`Properties`) in C# mit einer Validierungslogik (einem "Set Guard") versehen wollen, müssen wir verstehen, wie die Wertzuweisung im Hintergrund funktioniert. Ein naiver Ansatz führt direkt in eine Endlosschleife.

#### 1. Das Problem: Die Endlosschleife (`StackOverflowException`)

Versuchen wir, eine Eigenschaft zu erstellen, die im `set`-Accessor eine Prüfung durchführt. Wenn wir innerhalb des Setters versuchen, der Eigenschaft selbst den Wert zuzuweisen, ruft sich der Setter unendlich oft selbst auf.

**Beispiel:**

```csharp
public class Produkt
{
    // ACHTUNG: Dieser Code führt zu einem Absturz!
    public decimal Preis
    {
        set
        {
            if (value < 0)
            {
                throw new ArgumentException("Der Preis darf nicht negativ sein.");
            }
            // FEHLER: Dies ruft den 'set'-Accessor von 'Preis' erneut auf!
            // Es entsteht eine Endlosschleife (Rekursion).
            Preis = value; 
        }
        // Der Getter hätte dasselbe Problem.
        get
        {
            // FEHLER: Dies ruft den 'get'-Accessor von 'Preis' erneut auf!
            return Preis;
        }
    }
}
```

Das Programm stürzt mit einer `StackOverflowException` ab, weil der Aufrufstapel überläuft.

---

#### 2. Die klassische Lösung: Das manuelle "Backing Field"

Um die Endlosschleife zu verhindern, führen wir eine separate, private Variable ein. Diese wird "Backing Field" genannt, da sie im "Rücken" der Eigenschaft steht und die eigentlichen Daten speichert. Die Eigenschaft wird so zu einem reinen Vermittler (`getter`/`setter`), der den Zugriff auf dieses private Feld steuert.

**Beispiel:**

```csharp
public class Produkt
{
    // 1. Das private "Backing Field" wird deklariert.
    // Die Namenskonvention ist oft ein Unterstrich am Anfang.
    private decimal _preis;

    public decimal Preis
    {
        set
        {
            if (value < 0)
            {
                throw new ArgumentException("Der Preis darf nicht negativ sein.");
            }
            // Korrekt: Der Wert wird dem privaten Feld zugewiesen, nicht der Eigenschaft.
            _preis = value;
        }
        get
        {
            // Korrekt: Der Wert wird aus dem privaten Feld gelesen.
            return _preis;
        }
    }
}
```

Dieser Ansatz funktioniert einwandfrei und war jahrelang der Standard in C#. Der Nachteil ist der zusätzliche Code (Boilerplate) für die Deklaration und Verwaltung des privaten Feldes.

---

#### 3. Die moderne Lösung (ab C# 11): Das `field`-Keyword

Seit **C# 11** (.NET 7), das Ende 2022 veröffentlicht wurde, gibt es eine deutlich elegantere Lösung. Man kann das vom Compiler automatisch generierte Backing Field einer Auto-Property direkt über das kontextuelle Keyword `field` ansprechen.

Dadurch entfällt die Notwendigkeit, das Backing Field manuell zu deklarieren.

**Beispiel:**

```csharp
public class Produkt
{
    // Kein privates '_preis'-Feld mehr nötig!

    public decimal Preis
    {
        set
        {
            if (value < 0)
            {
                throw new ArgumentException("Der Preis darf nicht negativ sein.");
            }
            // Korrekt: 'field' greift auf das auto-generierte Backing Field zu.
            field = value;
        }
        // Der Getter kann eine einfache Auto-Property bleiben, wenn keine Logik nötig ist.
        get;
    }
}
```

Diese moderne Syntax kombiniert die Bequemlichkeit von Auto-Properties mit der Mächtigkeit von benutzerdefinierter Logik in den Accessoren. Der Code ist kürzer, sauberer und die Absicht ist sofort klar.

### Zugriffsmodifizierer (`public`, `protected`, `private set`, `init`)

Die `get`- und `set`-Accessoren einer Property können unterschiedliche Zugriffsmodifizierer haben, um die Kapselung feiner zu steuern.

* `public string Name { get; set; }`: Jeder kann den Wert lesen und schreiben.
* `protected string Name { get; set; }`: Nur die Klasse selbst und abgeleitete (erbende) Klassen können den Wert lesen und schreiben.
* `protected string Name { protected get; protected set; }`: Dies ist redundant. Der Modifizierer vor der Property (`protected`) gilt standardmäßig für beide Accessoren.
* `public string Name { get; private set; }`: Jeder kann den Wert lesen (`public get`), aber nur Code innerhalb derselben Klasse kann den Wert ändern (`private set`). Dies ist nützlich für Eigenschaften, die von der Klasse intern verwaltet, aber nach außen hin sichtbar sein sollen.
* `public string Name { get; init; }`: Jeder kann den Wert lesen. Der Wert kann aber **nur** während der Objektinitialisierung (im Konstruktor oder im Object Initializer) gesetzt werden. Danach ist die Eigenschaft schreibgeschützt. Dies fördert die **Immutability** (Unveränderlichkeit) von Objekten.

---

## Initializer

Initializer sind syntaktischer Zucker, um Objekte und Collections deklarativ und kompakt zu erstellen.

### Object Initializer

Ein Object Initializer ermöglicht es, direkt nach dem `new`-Aufruf die öffentlichen, beschreibbaren Properties eines Objekts in geschweiften Klammern zu setzen.

**Ablauf:**
1.  Der passende Konstruktor wird aufgerufen.
2.  Die Zuweisungen im Initializer-Block werden der Reihe nach ausgeführt.

Dies ist besonders nützlich für Data Transfer Objects (DTOs) oder Konfigurationsobjekte.

```csharp
public class ServerConfig
{
    public string IpAddress { get; set; }
    public int Port { get; set; }
    public bool UseHttps { get; set; }
    public int TimeoutSeconds { get; set; }

    public ServerConfig()
    {
        // Setzt Standardwerte
        IpAddress = "127.0.0.1";
        Port = 80;
        TimeoutSeconds = 30;
    }
}

public class AppSettings
{
    public string AppName { get; set; }
    public ServerConfig DatabaseServer { get; set; }
}

// Ohne Initializer
var config1 = new ServerConfig();
config1.Port = 8080;
config1.UseHttps = true;

// Mit Object Initializer
// Kompakter und deklarativer.
var config2 = new ServerConfig
{
    Port = 443,
    UseHttps = true,
    IpAddress = "192.168.1.100"
}; // TimeoutSeconds behält den Standardwert 30 aus dem Konstruktor.

// Nested Object Initializer
var appSettings = new AppSettings
{
    AppName = "MyWebApp",
    DatabaseServer = new ServerConfig
    {
        IpAddress = "db.example.com",
        Port = 5432,
        UseHttps = false
    }
};
```

Wir schauen uns noch ein Beispile an welches ein wenig auf die in den Properties erwähnten ``visibility modifiers`` (public, protected, private, ...) eingeht.

```csharp
public class Document
{
    // Jeder kann die ID lesen, aber sie kann nur bei der Erstellung des Objekts gesetzt werden.
    // Ideal für unveränderliche IDs.
    public Guid Id { get; init; }

    // Jeder kann den Inhalt lesen, aber nur die Document-Klasse selbst kann ihn ändern.
    // Nützlich für einen intern verwalteten Zustand.
    public string Content { get; private set; }

    // Die Erstellungszeit ist von außen lesbar, aber intern über den Konstruktor gesetzt.
    public DateTime CreationDate { get; } // Kurzform für { get; private set; } im Konstruktor.

    public Document(string initialContent)
    {
        Id = Guid.NewGuid();
        CreationDate = DateTime.UtcNow;
        Content = initialContent;
    }

    public void AppendText(string text)
    {
        // Die Änderung erfolgt kontrolliert über eine Methode.
        Content += text; 
    }
}

// Verwendung
var report = new Document("Start des Berichts.") 
{ 
    Id = Guid.NewGuid() // 'init' erlaubt dies.
};

// report.Id = Guid.NewGuid(); // FEHLER: 'init'-Property kann nicht nach der Initialisierung geändert werden.
// report.Content = "Neuer Inhalt"; // FEHLER: 'set' ist private.

report.AppendText(" Weiterer Text."); // Richtig: Kontrollierte Änderung über eine Methode.
Console.WriteLine(report.Content);
```

### Collection Initializer

Collection Initializer vereinfachen das Befüllen einer Collection bei ihrer Erstellung. Anstatt wiederholt die `Add`-Methode aufzurufen, können die Elemente direkt in geschweiften Klammern angegeben werden.

Voraussetzung: Die Klasse muss `System.Collections.IEnumerable` implementieren und eine `Add`-Methode mit der passenden Signatur für die Elemente besitzen.

**Beispiel mit `List<T>` und Objekten:**
```csharp
public class Project
{
    public string Name { get; set; }
    public int Priority { get; set; }
}

// Traditionelle Befüllung
var projects1 = new List<Project>();
var p1 = new Project { Name = "Relaunch Website", Priority = 1 };
projects1.Add(p1);
var p2 = new Project { Name = "Implement API", Priority = 1 };
projects1.Add(p2);
var p3 = new Project { Name = "Fix Bugs", Priority = 2 };
projects1.Add(p3);


// Mit Collection und Object Initializern kombiniert
// Deutlich lesbarer und kompakter.
var projects2 = new List<Project>
{
    new Project { Name = "Relaunch Website", Priority = 1 },
    new Project { Name = "Implement API", Priority = 1 },
    new Project { Name = "Fix Bugs", Priority = 2 }
};
```

**Beispiel mit `Dictionary<TKey, TValue>`:**
```csharp
// Die Initializer-Syntax für Dictionaries verwendet ebenfalls geschweifte Klammern für jedes Key-Value-Paar.
var httpStatusCodes = new Dictionary<int, string>
{
    { 200, "OK" },
    { 301, "Moved Permanently" },
    { 404, "Not Found" },
    { 500, "Internal Server Error" }
};

// Seit C# 6 gibt es auch eine Index-basierte Syntax, die manchen lesbarer erscheint.
var mimeTypes = new Dictionary<string, string>
{
    ["txt"] = "text/plain",
    ["html"] = "text/html",
    ["json"] = "application/json"
};
```