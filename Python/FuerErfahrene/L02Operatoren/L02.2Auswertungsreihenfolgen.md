# Auswertungsreihenfolgen von Operatoren
Die ersten √úberschriften erinnern an einen Mathematikunterricht. Wir m√ºssen uns jedoch einmal mit der ``Auswertungsreihenfolge`` von ``Operatoren`` besch√§ftigen und starten deshalb ein wenig trocken.

**Anmekrung:** Diese Einf√ºhrung ist nicht ausreichend um korrekte ``Terme`` im allgemeinen schreiben zu k√∂nnen. Wir stellen hier nur das n√∂tigste dar um ``logische Ausdr√ºcke`` darstellen zu k√∂nnen.

## Was sind Operatoren?
Wir merken uns:
>Operatoren verkn√ºpfen ``Variablen`` und ``Werte`` miteinander und erzeugen basierend auf diesen einen neuen ``Wert``.

Der folgende *+* ``Operator``, welcher die Bedeutung *"Addition"* hat, verkn√ºpft die Zahlen *35* und *17* und erzeugt einen neuen ``Wert`` *52*:

```python
print(35 + 17) # 52
```

Die Bedeutung eines ``Operators`` ist abh√§ngig vom ``Typ`` der ``Variablen`` bzw. ``Werte``, welche in den ``Operator`` "hineingegeben" werden. Das sehen wir bei dem Ausdruck *"35" + "17"*. Hier hat der Operator *+* nicht die Bedeutung der *"Addition"*, sondern der *"Concatenation"* (zusammenf√ºgen). Wir f√ºgen also die Zeichenkette *"35"* mit der Zeichenkette *"17"* zusammen, was *"3517"* ergibt. Die gew√ºnschte ``Operation`` (*Addition* oder *Concatenation*) ist somit nicht nur vom Symbol des ``Operators`` definiert. Wir nennen ``Operatoren`` welche kein eindeutiges Symbol besitzten ``√ºberladene Operatoren``.

```python
print("35" + "17") # "3517"
```

Das gleiche Verhalten gilt f√ºr ``Variablen``:

```python
first_int = 35
second_int = 17
third_int = 25
fourth_int = 47

print(first_int + second_int)
print(first_int + 17)

first_string = "35"
second_string = "17"

print(first_string + second_string)
print("35" + second_string)
```

Wir gehen sp√§ter mit Beispielen auf die so genannte ``√úberladung`` der ``Operatoren`` ein. Wir merken uns jedoch:
>Der Aufruf der gew√ºnschten ``Operation`` ist nicht eindeutig durch den ``Operator`` bestimmt. Die ``Typen`` der ``Werte`` bzw. ``Variablen`` welche in den ``Operator`` flie√üen entscheiden dies bei ``√ºberladenen Operatoren``.

## Wie werden mehrere gleiche Operatoren ausgewertet?
Wir beginnen zuerst mit ``Ausdr√ºcken``, welche nur eine Art von ``Operatoren`` verwenden. Wir nennen das kurz "``Ausdr√ºcke`` mit gleichen" ``Operatoren``.

Ein Aufruf eines ``Operators`` erzeugt einen  ``Wert`` mit einem ``Typ``. Dieser ``Wert`` kann direkt mit einem ``Operator`` und z.B. einen anderen ``Wert`` verkn√ºpft werden kann. Es kann also eine Art "Kette" gebildet werden.

```python
print(first_int + second_int + third_int + fourth_int) # 124
```

Wir betrachten nun die ``Auswertungsreihenfolge`` unserers gerade geschriebenen ``Ausdrucks``:
1. Suche den linkesten ``Operator``
2. Zuerst wir der links stehende Ausdruck vom ``Operator`` verarbeitet.
3. Dann der rechts stehende Ausdruck vom ``Operator``.
4. Der neu erzeugte ``Wert`` ersetzt den Ausdruck links, rechts und den ``Operator``. 
5. gehe zu 1. - Es wird wiederholt bis nur mehr ein ``Wert`` √ºbrig ist. Dieser ist unser ``Ergebnis``.

**Anmerkung:** Wir m√ºssen die gerade geschriebene Aufz√§hlung noch anpassen wenn wir Klammern und verschiedene ``Operatoren`` verwenden. Diese Aufz√§hlung ist also nur **vorl√§ufig** und nicht final!

Bestimmen wir die ``Auswertungsreihenfolge`` des vorherigen ``Ausdrucks``.
1. : Das *+* zwischen *first_int* und *second_int* ist das linkeste.

2. , 3. und 4.: *+* erzeugt einen neuen ``Wert`` aus *first_int* und *second_int*. Diser ist *52*. *52* Ersetzt den Ausdruck ``first_int + second_int``.
```python
print(52 + third_int + fourth_int)
```

5. und 1.: ich gehe zu **1.**  und suche den linkesten ``Operator``. Dieser ist das *+* zwischen *52* und *third_int*
```python
print(52 + third_int + fourth_int)
```

2. , 3. und 4.: *+* erzeugt einen neuen ``Wert`` aus *52* und *third_int*. Diser ist *77*. *77* Ersetzt den Ausdruck ``52 + third_int``.
```python
print(77 + fourth_int)
```

5. und 1.: ich gehe zu **1.**  und suche den linkesten ``Operator``. Dieser ist das *+* zwischen *77* und *fourth_int*
```python
print(77 + fourth_int)
```

2. , 3. und 4.: *+* erzeugt einen neuen ``Wert`` aus *77* und *fourth_int*. Diser ist *124*. *124* Ersetzt den Ausdruck ``77 + fourth_int``.
```python
print(124)
```

5. : Es wird wiederholt bis nur mehr ein ``Wert`` √ºbrig ist. *124* ist somit unser ``Ergebnis``.

Wir merken uns:
> ``Ausdr√ºcke`` gleicher ``Operatoren`` werden von *links* nach *rechts* aufgel√∂st. Den letzten ``Wert`` welche der ``Ausdruck`` erzeugt wird ``Ergebnis`` des ``Ausdrucks`` genannt. 

### Ist die Auswertungsreihenfolge bei gleichen Operatoren wichtig?
Obwohl wir die ``Auswertungsreihenfolge`` beider ``Ausdr√ºcke`` √§ndern, √§ndert sich das ``Ergebnis`` nicht.

```python
print(first_int + second_int + third_int + fourth_int) # 124
print(fourth_int + first_int + third_int + second_int) # 124
```

Die meisten ``Operatoren`` sind jedoch nicht so angenehm wie das hier verwendete **+**. Tausche nun *+* mit *-* aus. Bleibt das ``Ergebnis`` wieder gleich?

```python
print(first_int - second_int - third_int - fourth_int) # -54
print(fourth_int - first_int  - second_int - third_int) # -30
```

Nein. Es ist nun unterschiedlich. Wir gehen jedoch nicht n√§her auf dieses Verhalten ein und verweisen auf den Mathematik Kurs und die Konzepte ``assoziativ`` und ``kommutativ``. Jedoch merken wir uns:
> Wenn **nur** gleiche ``Operatoren`` vorkommen, ist die ``Auswertungsreihenfolge`` bei der *Addition* **+** und *Multiplikation* __*__ **nicht wichtig**.

> Wenn **nur** gleiche ``Operatoren`` vorkommen, ist die ``Auswertungsreihenfolge`` bei der *Subtraktion* **-** und *Division* __/__ **wichtig**.

Wichtig bedeutet hier das ``Ergebnis`` √§ndert sich.

### Wie steuern wir die Auswertungsreihenfolge bei gleichen Operatoren?
Wenn wir die Reihenfolge der Auswertung steuern wollen, *ohne die ``Werte`` zu vertauschen*, muss dies mit einer *Klammer* gemacht werden. Der n√§chste Ausdruck hat die gleiche Auswertungsreihenvolge wie jener aus der [vorherigen](#ist-die-reihenfolge-der-variablen-bei-gleichen-operatoren-wichtig) √úberschrift. Jedoch wird von uns hier die ``Auswertungsreihenfolge`` direkt durch *Klammern* angegeben. 

```python
print(((first_int - second_int) - third_int) - fourth_int) # -54
```

Wie bestimmen wir nun die ``Auswertungsreihenfolge``? Beginnen wir diesmal zuf√§llig und starten **nicht** links:
1. Suche einen beliebigen ``Operator`` und betrachte die ``Werte`` links und rechts davon.
2. Wenn einer der beiden ``Werte`` eine ``Klammer`` besitzt, gehe in diese ``Klammer`` hinein und starte bei der linkesten ``Operation``.
    1. Wiederhole bis **3.** passiert.
3. Ansonsten, wenn beiden ``Werte`` keine ``Klammern`` besitzen, f√ºhre die ``Operation`` durch, erzeuge einen neuen ``Wert`` und entferne die ``Klammer``, falls vorhanden.
    1. Wiederhole bis **2.** passiert, **oder** keine ``Klammern`` mehr vorhanden sind, **oder** nur mehr ein ``Wert`` √ºbrig ist. Das ist unser ``Ergebnis``. Falls keine ``Klammern`` mehr vorhanden sind, werte von links nach rechts aus.

**Anmerkung:** Wir m√ºssen die gerade geschriebene Aufz√§hlung noch anpassen wenn wir verschiedene ``Operatoren`` verwenden. Diese Aufz√§hlung ist also nur **vorl√§ufig** und nicht final!

Bestimmen wir nun die ``Auswertungsreihenfolge`` des vorherigen ``Ausdrucks``.
```python
print(((first_int - second_int) - third_int) - fourth_int) # -54
```
1. : Durch Zufall haben wir das *-* zwischen *third_int* und der ``Klammer`` gew√§hlt.

2. : Da die linke ``Variable`` eine ``Klammer`` besitzt, gehen wir in diese hinein. 

3. : Da innerhalb dieser ``Klammer`` beide ``Werte`` **keine** ``Klammer`` besitzen, f√ºhre die ``Operation`` durch und...
```python
print((-7) - fourth_int) 
```
... entferne die ``Klammer``.
```python
print(-7 - fourth_int) 
```

3. : Da innerhalb dieser ``Klammer`` beide ``Werte`` **keine** ``Klammer`` besitzen, f√ºhre die ``Operation`` durch.
```python
print(-54) 
```
Da nur mehr ein ``Wert`` √ºbrig ist, ist unser ``Ergebnis`` *-54*.

Wir merken uns:
> Die ``Auswertungsreihenfolge`` von ``Ausdr√ºcke`` gleicher ``Operatoren`` mit ``Klammern``, ist durch die ``Klammerung`` vorgegeben. 

> Die letzte ``Operation`` welche durchgef√ºhrt wird, wird ``letzauszuf√ºhrende Operation`` genannt. Diese ist besonders wichtig f√ºr den Umgang von ``logischen Ausdr√ºcken``.

Wir k√∂nnen nun die ``Auswertungsreihenfolge`` √§ndern, indem wir die ``Klammern`` nach unserem Ermessen setzten. Bestimmen wir die ``Auswertungsreihenfolge`` des folgenden ``Ausdrucks``.

```python
print(first_int - (second_int - third_int) - fourth_int)
```

1. : Durch Zufall haben wir das *-* zwischen *first_int* und der ``Klammer`` gew√§hlt.

2. : Da die rechte ``Variable`` eine ``Klammer`` besitzt, gehen wir in diese hinein. 

3. : Da innerhalb dieser ``Klammer`` beide ``Werte`` **keine** ``Klammer`` besitzen, f√ºhre die ``Operation`` durch und...
```python
print(first_int - (-8) - fourth_int)
```
... entferne die ``Klammer``.
```python
print(first_int - -8 - fourth_int)
```

3. : Da keine ``Klammern`` mehr vorhanden sind, werte von links nach rechts aus.
```python
print(43 - fourth_int)
```

3. : Da keine ``Klammern`` mehr vorhanden sind, werte von links nach rechts aus.
```python
print(-4)
```

## Wie werden mehrere verschiedene Operatoren ausgewertet?
Wir verzichten nun auf die Verwenung von gleichen ``Operatoren`` in einem ``Ausdruck``. Die bis jetzt ausgef√ºhrten Gedankenspiele werden nun ben√∂tigt, da wir nun verschiedene ``Operatoren`` in einem ``Ausdruck`` zulassen. Wir haben hier 2 M√∂glichkeiten. Entweder, wir verwenden f√ºr jede ``Operation`` eine ``Klammer``, oder f√ºhren eine ``Auswertungsreihenfolge`` bedingt auf die benachbarten ``Operatoren`` ein.

Da die Verwendung von ``Klammern`` in jedem Schritt unleserliche ``Ausdr√ºcke`` erzeugt, f√ºhren wir eine ``Auswertungsreihenfolge`` ein. Von der Schule ist vl. noch der Ausdruck **KlaBuStri** bekannt. Dieser soll die St√§rke der Bindung zwischen ``Operatoren`` ausdr√ºcken.
1) Klammern binden am st√§rksten unabh√§ngig von den benachbarten ``Operatoren``
2) ``Punkt-Operatoren`` (*, /) binden st√§rker als nicht ``Strich-Operatoren`` (+, -)
3) ``Strich-Operatoren`` binden am schw√§chsten

Da wir jedoch nun eine gr√∂√üere Anzahl an ``Operatoren`` besitzen welche kombiniert werden k√∂nnen, m√ºssen wir diese Aufz√§hlung anpassen.
Wir merken uns:
>1) Klammern binden am st√§rksten unabh√§ngig von den benachbarten ``Operatoren``
>2) innerhalb von ``arithmetischen Operatoren`` gilt:
>    1) ``Punkt-Operatoren`` (*, /) binden strker als nicht ``Strich-Operatoren`` (+, -)
>    2) ``Strich-Operatoren`` binden am schw√§chsten
>3) ``arithmetische Operatoren`` binden st√§rker als ``Vergleichsoperatoren`` (``<, >, <=, >=, ==, !=, in, not in, is, is not``). Innerhalb dieser gilt:
>    1) Alle sind gleichwertig, deshalb ist die ``Auswertungsreihenfolge`` innerhalb dieser links nach rechts.
>4) ``Vergleichsoperatoren`` binden st√§rker als der ``Zuweisungs Operator`` (``:=``, damit eine Zuweisung in einem komplizierteren ``Ausdruck`` geschrieben werden kann, muss ``:=`` anstatt ``=`` verwendet werden).
>5) Der ``Zuweisungs Operator`` bindet st√§rker als ``logische Operatoren`` (``not, and, or``). Innerhalb dieser gilt:
>    1) ``not`` bindet am st√§rksten
>    2) ``and`` bindet st√§rker als ``or``
>    3) ``or`` bindet am schw√§chsten.

Es k√∂nnte somit der Begriff **KlaBuStriVerZuNoTAndOr** erzeugt werden. Dieser scheint jedoch begrenzt sinnvoll zu sein.

Bestimmen wir nun die ``Auswertungsreihenfolge`` von ``Ausdr√ºcke`` welche verschiedene ``Operatoren`` zulassen. Dazu passen wir unsere Regeln entsprechend an:
Wir merken uns:
>1. Verwende die linkeste ``Variable`` oder ``Wert`` und betrachte dessen ``Operator``. Betrachte nun die ``Werte`` links und rechts dieses ``Operators``.
>2. Wenn einer der beiden ``Werte`` des ``Operators`` eine ``Klammer`` besitzt, gehe in diese ``Klammer`` hinein und starte bei der linkesten ``Operation``.
>    1. Wiederhole bis **3.** passiert.
>3. Ansonsten, ber√ºcksichtige alle ``Operatoren`` innerhalb der ``Klammer`` ohne eine **weitere** ``Klammer`` zu √∂ffnen. F√ºre jene ``Operation`` durch welche am st√§rksten bindet und erzeuge einen neuen ``Wert``. Entferne die ``Klammer`` falls die ``Operation`` die letzte innerhalb dieser war. Falls die ``Klammer`` entfernt wurde, ber√ºcksichtige alle ``Operatoren`` innerhalb der neuen ``Klammer``. W√§hle den st√§rkst bindenden ``Operator``.
>    1. Wiederhole bis **2.** passiert **oder** nur mehr ein ``Wert`` √ºbrig ist. Das ist unser ``Ergebnis``.

Betrachten folgendes komplexes Beispiel.
```python
print(not(first_int + (second_int - third_int) * fourth_int > 85 and (fourth_int := fourth_int + 5) != 10)) # ü§î
```

1. : Die linkeste ``Variable`` oder ``Wert`` ist *first_int*.

2. : Da einer der ``Werte`` der ``Operation`` eine ``Klammer`` besitzt, springen wir in diese ``Klammer``.

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische Operation`` **-** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen. Wir entfernen die ``Klammer``, da die letzte ``Operation`` innerhalb dieser ausgewertet wurde und ber√ºcksichtigen die neue ``Klammer``.
```python
print(not(first_int + -8 * fourth_int > 85 and (fourth_int := fourth_int + 5) != 10))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische Operation`` __*__ ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```python
print(not(first_int + -376 > 85 and (fourth_int := fourth_int + 5) != 10))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische Operation`` **+** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```python
print(not(-341 > 85 and (fourth_int := fourth_int + 5) != 10))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Vergleichsoperation`` **>** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```python
print(not(False and (fourth_int := fourth_int + 5) != 10))
```
**Anmerkung:** Hier wird bereits eine sogenannte ``minimal evaluation`` durchgef√ºhrt. Diese kann verwendet werden, wenn die ``letzauszuf√ºhrende Operation`` eine bin√§re ``logische Operation`` ist. Da wir ein logisches UND mit einem ``False`` Wert haben, k√∂nnen wir bereits den ``Ausdruck`` auf ``false`` auswerten. **Das ist hier dramatisch!** Denn wir haben eine Zuweisung auf der rechten Seite des logischen UNDs, welche damit nicht ausgef√ºhrt wird. Dehalb ist es nicht √ºblich Zuweisungen ``:=`` in Verbindung mit ``logischen Ausdr√ºcken`` zu verwenden.

2. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Vergleichsoperation`` **!=** ist und einer der ``Werte`` der ``Operation`` eine ``Klammer`` besitzt, springen wir in diese ``Klammer``.

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``arithmetische operation`` **+** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```python
print(not(False and (fourth_int := 52) != 10))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Zuweisungsoperation`` **:=** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen. Wir entfernen die ``Klammer``, da die letzte ``Operation`` innerhalb dieser ausgewertet wurde und ber√ºcksichtigen die neue ``Klammer``.
```python
print(not(False and 52 != 10))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``Vergleichsoperation`` **!=** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen. 
```python
print(not(False and True))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``logische Operation`` **and** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```python
print(not(False))
```

3. : Da die st√§rkst bindende ``Operation`` innerhalb der ``Klammer`` die ``logische Operation`` **not** ist, f√ºhren wir diese aus. Wir erzeugen einen neuen ``Wert``, da wir keine ``Klammer`` √∂ffnen m√ºssen.
```python
print(True)
```