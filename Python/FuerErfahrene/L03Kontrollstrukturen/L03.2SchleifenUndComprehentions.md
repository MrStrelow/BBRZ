# Kontrollstrukturen - Java vs. Python 

## 1. **Bedingte Anweisung**
### Java:
```java
if (bedingung) {
    // Code Block
}
```

### Python:
```python
if bedingung:
    # Code Block
```

**Unterschiede**:
- In Java muss die Bedingung immer in Klammern gesetzt werden, wÃ¤hrend in Python keine Klammern benÃ¶tigt werden. Der Codeblock in Python wird durch EinrÃ¼ckung (Whitespace) gesteuert.

## 2. **If-Verzweigung**
### Java:
```java
if (bedingung) {
    // Code Block
} else {
    // Code Block
}
```

### Python:
```python
if bedingung:
    # Code Block
else:
    # Code Block
```

**Unterschiede**:
- Auch hier wird in Java `else` mit Klammern verwendet, wÃ¤hrend Python nur EinrÃ¼ckung verwendet.

## 3. **Else-if (Mehrfachverzweigung)**
### Java:
```java
if (bedingung1) {
    // Code Block
} else if (bedingung2) {
    // Code Block
} else {
    // Code Block
}
```

### Python:
```python
if bedingung1:
    # Code Block
elif bedingung2:
    # Code Block
else:
    # Code Block
```

**Unterschiede**:
- In Java verwenden wir `else if` fÃ¼r die Verzweigung, wÃ¤hrend in Python das SchlÃ¼sselwort `elif` genutzt wird.

## If Expression (TernÃ¤rer Operator)
### Python:
Allgemein wird bei ``Kontrollstrukturen`` zwischen ``Ausdruck`` (Expression) und ``Anweisung`` (Statement) unterschieden. Schauen wir uns zuerste ein Beispiel fÃ¼r einen ``Ausdruck`` an.

```python
c = 5 if a > b else 20
print(c)

# oder direkt, ohne Verwendung von einer Variable
print(5 if a > b else 20)
```

Wir sehen in obigen Code, dass die Logik einer ``If-Verzweigung`` in einer anderer Reihenfolge und innerhalb einer Zeile dargestellt wird. Wir nennen dies ``If-Expression``. Jedoch erzeugt dieser ``Ausdruck`` direkt einen ``Wert`` welchen wir weiter verwenden kÃ¶nnen. Wir lesen somit, "weise der ``Variable`` c den ``Wert`` 5 zu, wenn ``a>b``. Ansonsten 20".

In bekannter schreibweise ist hier die ``If-Verzweigung`` welche eine ``Anweisung`` ist. Wir kÃ¶nnen dadurch den ``Zuweisungsoperator`` nicht mehr verwenden. Im allgemeinen benÃ¶tigen ``Anweisungen`` ``Variablen`` innerhalb dieser um Ergebnisse fÃ¼r spÃ¤ter verwendbar zu machen. 

```python
if a > b:
    c = 5
else:
    c = 20

print(c) # variable c um diese spÃ¤ter/nach der Anweisung verwenden zu kÃ¶nnen.
```

Anmerkung: Es gibt neben dem ``If-Statement`` vs. ``If-Expression`` den Unterschied zwischen einem ``Switch-Statement`` und einer ``Switch-Expression``. Letzteres wird auch meistens ``Pattern-Matcher`` genannt, da komplexere Bedinungen hier modelliert werden kÃ¶nnen, welche zuerst nur sinnvoll mit ``if-Statements`` umsetzbar waren.

### JAVA:
Die ``If-Expression`` wird in JAVA oder anderen Programmiersprachen auch ``TernÃ¤rer Operator`` oder ``?: Operator`` genannt. TernÃ¤r bedeutet ``dreifach`` und ist neben ``unnÃ¤r`` (einfach) und ``binÃ¤r`` (zweifach) eine Angabe von den ``Argumenten`` eines ``Operators``. Da es nur einen ``TernÃ¤ren Operator`` gibt, wird oft die ``If-Expression`` so genannt. 

Es Ã¤ndert sich nur leicht die ``Syntax`` zum Beispiel oben. Es wird die ``Bedingung`` und der ``Wert`` falls die ``Bedingung`` wahr ist, vertauscht. 
Zudem wird *if* zu *?* und *else* zu *:*.

```java
//  c = 5     if a > b else 20 // Pyhton
int c = a > b ?  5     :    20;
System.out.println(c);

// oder direkt, ohne Verwendung von einer Variable
System.out.println(a > b ? 5 : 20);
```

## 4. **Switch-Statement**
### Java:
```java
switch (variable) {
    case wert1:
        // Code Block
        break;
    case wert2:
        // Code Block
        break;
    default:
        // Code Block
}
```

### Python:
```python
# In Python gibt es kein direktes "switch", aber man kann `if`-Bedingungen verwenden:
if variable == wert1:
    # Code Block
elif variable == wert2:
    # Code Block
else:
    # Code Block
```

**Unterschiede**:
- Java hat das `switch`-Statement nativ, Python hingegen nicht. In Python wird hÃ¤ufig eine `if`-Verkettung genutzt.

## 5. **While-Schleife**
### Java:
```java
while (bedingung) {
    // Code Block
}
```

### Python:
```python
while bedingung:
    # Code Block
```

**Unterschiede**:
- In Java wird `while` mit Klammern geschrieben, in Python ohne.

## 6. **Do-While-Schleife**
### Java:
```java
do {
    // Code Block
} while (bedingung);
```

### Python:
```python
# Python hat keine native do-while Schleife, aber man kann eine Endlosschleife verwenden:
while True:
    # Code Block
    if not bedingung:
        break
```

**Unterschiede**:
- Python bietet keine `do-while` Schleife, aber sie kann mit einer `while True` Schleife nachgebildet werden.

## 7. **For-Schleife**
### Java:
```java
for (int i = 0; i < 10; i++) {
    // Code Block
}
```

### Python:
```python
for i in range(10):
    # Code Block
```

**Unterschiede**:
- In Java muss der Schleifenindex explizit deklariert werden, wÃ¤hrend Python dies intern mit `range()` erledigt.

## 8. **For-Each-Schleife**
### Java:
```java
for (Typ element : liste) {
    // Code Block
}
```

### Python:
```python
for element in liste:
    # Code Block
```

**Unterschiede**:
- Die Syntax ist sehr Ã¤hnlich, aber in Python wird einfach `in` anstelle von `:` verwendet.


## List/Dicitonary Comphrehention

``Comprehensions`` in Python sind eine elegante und kompakte MÃ¶glichkeit, ``Listen``, ``Sets`` und ``Dictionaries`` zu erstellen. Sie ermÃ¶glichen es, eine ```Collection`` basierend auf einer vorhandenen ``Collection`` zu erstellen, indem eine Schleifen- und Verzweigungslogik in einer einzigen Zeile anwendet wird.

Anmerkung fÃ¼r die Zukunft: Im Vergleich zu ```map`` und ``filter`` ``Funktionalen`` welche in L04Funktionen_hoeherer_Ordnung besprochen werden, sind ``Comprehentions`` + ``Generator`` fast immer zu bevorzugen.

### List Comprehension
Wann verwenden wir dieses scheinbar neue Werkzeug? Wenn wir bereits eine ``Liste`` haben, hat diese eine ``Dimension``(z.B. eine ``Liste`` mit 5 ``Integer`` Zahlen hat ``Dimension`` 5). Falls wir fÃ¼r unser Problem eine **neue** ``Liste`` brauchen welche die gleiche ``Dimension`` wie die ursprÃ¼ngliche hat, dann wÃ¤re "unnÃ¶tig" dem Computer folgendes mitzuteilen.

```python
numbers = [1, 2, 3, 4, 5] # ursprÃ¼ngliche Liste
squares = [] # unnÃ¶tig: um eine neue Liste befÃ¼llen zu kÃ¶nnen, muss diese erstellt werden

for x in numbers:
    square = x ** 2
    squares.append(square) # unnÃ¶tig: es wÃ¤re angenehm wenn diese zuweisung nicht notwendig wÃ¤re

```

Wir nutzen nun die ``Struktur`` der ``Liste`` **numbers** um die dimensionen der erzeugten ``Liste`` zu definieren. Diese neue hat deshalb ebenfalls 5 Elemente.
Wir wollen jedoch nicht nur die Daten einzeln aus **numbers** lesen, wir wollen diese manipulieren bevor wir diese in die neue ``Liste`` schreiben.
Wir schaffen das durch folgende ``Syntax``:

```python
numbers = [1, 2, 3, 4, 5]
# List Comprehension
squares = [x ** 2 for x in numbers]
print(squares)  # Output: [1, 4, 9, 16, 25]
```

Hier sehen wir folgendes: 
* ``[]`` erzeugt uns eine leere Liste, jedoch wir wollen diese nicht leer haben, deshalb...
* schreiben wir innerhalb der eckigen Klammern ``[]`` einen Ausdruck z.B. ``x * 2`` welcher beschreibt was mit den ``Elementen`` der ursprÃ¼nglichen ``Liste`` passiert (``Zuweisungslogik``).
* Danach ist relevant welche Elemente wir aus der ursprÃ¼nglichen ``Liste`` verwenden. Wir verwenden dazu die bekannte ``Syntax`` einer ``For-Schleife`` (``Schleifenlogik``). 

Die bekannte normale ``For-Schleife`` ist also genau verkehrt geschrieben. Dort ist zuerste die ``Schleifenlogik`` und nach potentiell mehreren EinrÃ¼ckungen, die ``Zuweisungslogik`` geschrieben. Es kann dadurch potentiell leichter sein, die Idee des Codes zu verstehen, wenn ``Comprehentions`` verwendet werden, da hier am Anfang die ``Zuweisungslogik`` steht. ZusÃ¤tzlich ist der "unnÃ¶tige" Code ohne ``Comprehentions`` welcher Initialisierungen und Zuweisungen fÃ¼r die neuen Liste Ã¼bernimmt, nicht vorhanden. 

#### Verschachtelte Comprehentions
Was wenn die ``Dimension`` der ``Struktur`` nicht n sondern komplizierter ist? Wir schauen uns nun ein 2-D "Brett" mit Dimension ``(n,n)`` an. Unser Brett soll Elemnte des Typs ``String`` besitzen um spÃ¤ter ein Muster in dieses Zeichnen zu kÃ¶nnen. Ein Beispiel ist folgendes:

Der Code ein solches zu erstellen ist in bekannter ``Syntax`` folgender:

```python
dimension = 3
field = []
for _ in range(dimension): # Achtung! Hier ist Variable Dimension nur gleich 3. Die Dimension der Liste field ist jedoch (3,3) 
    row = []
    for _ in range(dimension):
        row.append("ğŸ”·") # oder None
    
    field.append(row)

print(field) # [["ğŸ”·", "ğŸ”·", "ğŸ”·"], ["ğŸ”·", "ğŸ”·", "ğŸ”·"], ["ğŸ”·", "ğŸ”·", "ğŸ”·"]]
```

Diese Logik nun als ``Comprehention``. Da wir keine "ursprÃ¼ngliche" ``Liste`` besitzen von welcher wir die ``Dimensionen`` Ã¼bernehmen kÃ¶nnen, mÃ¼ssen wir mit ``range(dimension)`` die Wiederholungen der ``Schleife`` steuern.

```python
dimension = 3
[["ğŸ”·" for _ in range(dimension)] for _ in range(dimension)] # [["ğŸ”·", "ğŸ”·", "ğŸ”·"], ["ğŸ”·", "ğŸ”·", "ğŸ”·"], ["ğŸ”·", "ğŸ”·", "ğŸ”·"]]
```

Wir sehen folgendes:
* Wir beginnen mit der ``Zuweisungslogik`` welche nur die Weitergabe der Variable ``Symbol`` an die neue Liste ist. 
* Wir wieder holen dieses Symbol so oft bis wir eine *Zeile* in unsrem Brett haben. Die erste ``Comprehention`` ``[symbol for _ in range(dimension)]`` ist also die 1. *Zeile*.
* Wir wiederholen nun fÃ¼r jede *Reihe* diese ``Comprehention``. Der Ergebnis des Asudrucks der *Reihe* ``[symbol for _ in range(dimension)]`` wir nun in ein weiteres ``[]`` gegeben und ``for _ in range(dimension)`` mal wiederholt.
* Da das Ergebnis von ``[symbol for _ in range(dimension)]`` eine ``Liste`` ist, und wir diesen Ausdruck nun in eine weitere ``Comprehention`` geben, erhalten wir eine ``Liste`` in einer ``Liste``.

#### Dimension des Inputs: $n$ und Dimension des Outputs: $n^n$
Was aber wenn wir nicht eine komplizierte Struktur wie ein ``Liste`` in einer ``Lsite`` wollen, sondern eine "flache" Liste haben wollen mit allen Ergebnissen?
Stellen wir uns die gleiche Anforderung wie zuvor vor, ein erstellen eines 2D-Brettes, jedoch **ohne** die Logik der *eine Zeile ist in einer Liste und alle Zeilen sind wieder in einer Liste* ``[[ğŸ”·,ğŸ”·],[ğŸ”·,ğŸ”·]]``. Wir wollen diese also *zusammendrÃ¼cken* (flatten) ``[ğŸ”·,ğŸ”·,ğŸ”·,ğŸ”·]``. 

Anmerkung: Falls schon eine Liste vorhanden ist, welche wir zusammendrÃ¼cken wollen, sind solche Operationen in ``Packages`` unter verschiedenen Namen bekannt. 
* numpy, flatlist: *flatten*, 
* numpy: *ravel* (**call by reference**), 
* pandas: *explode*, 
* itertools: *chain*.

Wir wollen aber mit einer ``Comprehention`` direkt eine solche ``Liste`` erstellen. Wie haben im vorherigen Code ``Comprehentions`` in ``Comprehentions`` geschachtelt. Was wenn wir einfach diese Schachtelung`von den Eckigen Klammern ``[[... for] for]`` weg lassen?

```python
dimension = 2
[ ["ğŸ”·" for _ in range(dimension)] for _ in range(dimension)] # Input: [0,1] -> [['ğŸ”·','ğŸ”·'],['ğŸ”·','ğŸ”·']]
[  "ğŸ”·" for _ in range(dimension)  for _ in range(dimension)] # Input: [0,1] -> ['ğŸ”·','ğŸ”·','ğŸ”·','ğŸ”·']
```
Das scheint zu funktionieren.  

#### Verzweigung bei Comprehentions - If-Expression
Was wenn wir jedoch nun ``[[ğŸ”·,â—½,â—½],[ğŸ”·,ğŸ”·,â—½], [ğŸ”·,ğŸ”·,ğŸ”·]]`` erzeugen wollen. Wenn wir die inneren ``Listen`` als *Zeilen* sehen, erkennen wir eine Art Dreieck. 
```
ğŸ”·â—½â—½
ğŸ”·ğŸ”·â—½
ğŸ”·ğŸ”·ğŸ”·
```

Hier scheint eine ``Verzweigung`` notwendig zu sein um das Symbol ``â—½`` oder ``ğŸ”·`` einfÃ¼gen zu kÃ¶nnen.

Wir schreiben dazu *links* von ``for`` eine  [``If-Expression``](#if-expression-ternÃ¤rer-operator) ``"ğŸ”·" if x <= 0 else "â—½"``. Es wird also sichergestellt, dass hier ein ``Wert`` zurÃ¼ckgegeben wird, entweder ``ğŸ”·`` oder ``â—½``. Jedoch welcher ist abhÃ¤ngig von der ``Bedingung``.

Wir erzeugen nun die 1. *Zeile* unsere Dreiecks. 
```python
dimension = 3
["ğŸ”·" if x <= 0 else "â—½" for x in range(dimension)] # ['ğŸ”·', 'â—½', 'â—½']
```

Es fehlt uns nun eine weitere verschachtelte ``Comprehention`` welche nun die Generierten *Zeilen* nimmt und diese in eine ``Liste`` gibt.

```python
dimension = 3
[["ğŸ”·" if x <= y else "â—½" for x in range(dimension)] for y in range(dimension)] 
# [['ğŸ”·', 'â—½', 'â—½'], ['ğŸ”·', 'ğŸ”·', 'â—½'], ['ğŸ”·', 'ğŸ”·', 'ğŸ”·']]
```

Wir erkennen im obigen Code dass die Reihenfolge ausschlaggeben ist fÃ¼r die Logik welche wir implementieren. 
Es ist also wichtig in der Ã¤uÃŸeren ``Comprehention`` die *Zeilen* welche mit ``y`` als Index codiert sind in eine ``Liste`` zusammenzufassen. Die innere ``Comprehention`` kÃ¼mmert sich mit der befÃ¼llung einer Zeile. Hier wird ``x`` als Index der *Spalte* angesehen. In vorherigen Programmen mussten wir die von der ``for`` generieren ``Variable`` nicht weiter verwenden. Wir haben dort einfachheitshalber ``for _ in range(dimension)`` geschrieben, da mit ``_`` keine Verwendung diese ``Variable`` symbolisiert werden sollte.
Nun brauchen wir aber in der ``Bedingung`` die Spalten- sowie Zeilenindices. Wir sagen in der ``Bedingung``, "Wenn der Spaltenindex kleiner wie der Zeilenindex ist, dann zeichnen wir ğŸ”·, sonst â—½". Das hat zur Fole, dass alles links und inklusive der ``Diagonale``, ğŸ”· wird und alles rechts davon â—½.

#### Bedingung bei Comprehentions - Filter
Eine Angabe einer ``Bedingte Anweisung`` erscheint auf den ersten Blick als nicht sinnvoll. Diese kann z.B. etwas zurÃ¼ckgeben wenn die ``Bedingung`` erfÃ¼llt ist, jedoch passiert *nichts* wenn die ``Bedingung`` *nicht* erfÃ¼llt ist. Was soll nun mit dem ``Wert`` in z.B. der ``Liste`` numbers hier ``x * 2 for x in numbers if x < 20`` passieren?

```python
numbers = [1, 2, 3, 20]
[x * 2 for x in numbers if x < 20] # [2, 4, 6]
```

Wir sehen, dass 20 ignoriert wurde. Wir haben hier *rechts* vom ``for`` also einen ``Filter``. Je nachdem wo wir diesen Angeben filtert dieser an verschiedenen Stellen, falls die Comprehention verschachtelt ist.

```python
numbers = [[1, 2], [3, 20]]
[[x * 2 for x in elem if x < 20] for elem in numbers if sum(elem) > 5] # [[6]]
```

Anmerkung: Wir schreiben das ``if`` wenn es einen ``Filterausdruck`` darstellen soll **rechts** vom ``for``. Aber warum? st es nicht einfacher es konsistent immer links davon zu schreiben? Das Problem ist wenn wir ``filtern`` und eine ``If-Expression`` verwenden wollen, ist es Ã¤uÃŸerst unÃ¼bersichtlich ``[x * 2 if x > 10 else x * 4 if x < 20 for x in numbers]`` zwischen den ZustÃ¤ndigkeiten zu unterscheiden. Damit ist gemeint, Welche Bedingung ist fÃ¼r den ``Filter`` und welche fÃ¼r die ``If-Expression`` zustÃ¤ndig? Der ``Interpreter`` hÃ¤tte an sich kein Problem einen solchen Ausdruck korrekt einlesen zukÃ¶nnen, es wÃ¤re also *technisch gleichwertung* umsetzbar alles *links* zu schreiben. Python hat sich aber dagegen entschieden um ``syntaktische`` Klarheit fÃ¼r den Programmieren zu schaffen. Rechts Filter, Links If-Expression.

Dieser ``Ausdruck`` hat *nichts* mit einer ``If-Expression`` zu tun. Diese musste links stehen, da diese ``Expression`` zusammegefasst das in die Liste geschreibene Element . Wir kÃ¶nnten damit z.B. entescheiden ob wir mal 2 oder mal 4 rechnen ``x * 2 if x > 10 else x * 4``. 

Es ist nicht wie bei einer [Verzweigung in Comprehentions](#verzweigung-bei-comprehentions---if-expression) wo mit Sicherheit ein Wert zurÃ¼ck gegeben wird, jedoch welcher ist offen. Hier bei der ``Bedinung`` wollen wir die zu erzeugende Liste mit der Angegebenen ``Bedingung`` ``filtern``.

```python
numbers = [1, 2, 3, 10, 11, 12, 13, 20]
[x * 2 if x > 10 else x * 4 for x in numbers if x < 20]
# [4, 8, 12, 40, 22, 24, 26]
```

Anmerkung: Auch ohne Verschachtelung ist eine Ordnung der filter mÃ¶glich. Jedoch mÃ¼ssen wir uns hier ein wenig genauer hinschauen um zu verstehen was passiert:
```python
numbers = [1, 2, 3, 20]
[x * y for x in numbers if x < 20 for y in numbers if y > 2] # [3*1=3, 20*1=20, 3*2=6, 20*2=40, 3*3=9, 20*3=60]
```

### Ã„quivalent in Java
In Java gibt es keine direkte Entsprechung zu List-Comprehensions, aber wir kÃ¶nnen eine Ã¤hnliche FunktionalitÃ¤t mit Streams und Lambdas erreichen. Die Idee hinter diesen gleich den Ideen von ``L04Funktionen_hoeherer_Funktionen`` in Python. 
import java.util.List;
import java.util.stream.Collectors;
```java
public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        List<Integer> squares = numbers.stream()
                                       .map(x -> x * x)
                                       .collect(Collectors.toList());
        System.out.println(squares);  // Output: [1, 4, 9, 16, 25]
    }
}
```
In Java verwenden wir Streams und die map-Funktion, um eine Transformation auf die Liste anzuwenden.

### Dictionary Comprehension
Dictionary Comprehension wird verwendet, um ein Dictionary basierend auf einer bestehenden Sammlung zu erstellen, wobei SchlÃ¼ssel-Wert-Paare generiert werden.

```python
# Python Dictionary Comprehension
numbers = [1, 2, 3, 4, 5]
squares_dict = {x: x ** 2 for x in numbers}
print(squares_dict)  # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

Hier wird ein Dictionary erstellt, bei dem die SchlÃ¼ssel die Zahlen aus der Liste sind und die Werte die Quadrierungen dieser Zahlen.

Es gelten zudem alle in [List-Comprehention](#list-comprehension) angemerkten Themen fÃ¼r die [Dictionary Comprehension](#dictionary-comprehension).

#### Anwendungen

TODO

### Ã„quivalent in Java
In Java gibt es keine eingebaute Syntax fÃ¼r Dictionary Comprehensions. Stattdessen verwenden wir einen Map und Streams.
```java
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        Map<Integer, Integer> squaresMap = numbers.stream()
                                                  .collect(Collectors.toMap(x -> x, x -> x * x));
        System.out.println(squaresMap);  // Output: {1=1, 2=4, 3=9, 4=16, 5=25}
    }
}
```
In Java verwenden wir die Collectors.toMap-Methode, um eine Map zu erstellen, wobei der erste Parameter den SchlÃ¼ssel und der zweite den Wert angibt.

## NÃ¼tzliche Methoden in Python:

### 1. **zip**
Die `zip`-Funktion kombiniert mehrere Iterierbare und gibt Tupel zurÃ¼ck, die die Elemente aus den Iterierbaren paarweise enthalten.

### Beispiel:
```python
liste1 = [1, 2, 3]
liste2 = ['a', 'b', 'c']
result = zip(liste1, liste2)
print(list(result))  # [(1, 'a'), (2, 'b'), (3, 'c')]

# for first, second in result:
for first, second in zip(liste1, liste2):
    print(str(first) + "--" + second)
    print('##########')
```
Output:
```
1--a
##########
2--b
##########
3--c
##########
```

### 2. **enumerate**
Die `enumerate`-Funktion gibt jedes Element einer Liste zusammen mit seinem Index zurÃ¼ck.

### Beispiel:
```python
liste = ['a', 'b', 'c']
for index, value in enumerate(liste):
    print(index, value)
# Ausgabe: 0 a, 1 b, 2 c
```

```python
liste1 = [1, 2, 3]
liste2 = ['a', 'b', 'c']
result = zip(liste1, liste2)
print(list(result))  # [(1, 'a'), (2, 'b'), (3, 'c')]


# for first, second in result:
for i, (first, second) in enumerate(zip(liste1, liste2), start=50):
    print(str(first) + "--" + second + ": in iterator: " + str(i))
    print('##########')
```

### 3. **sorted**
Die `sorted`-Funktion gibt eine sortierte Kopie einer Liste zurÃ¼ck.

### Beispiel:
```python
liste = [3, 1, 4, 1, 5, 9]
sorted_liste = sorted(liste)
print(sorted_liste)  # [1, 1, 3, 4, 5, 9]
```

### 4. **all und any**
- `all()` gibt `True` zurÃ¼ck, wenn alle Elemente eines Iterierbaren `True` sind.
- `any()` gibt `True` zurÃ¼ck, wenn mindestens ein Element eines Iterierbaren `True` ist.

### Beispiel:
```python
liste = [True, True, False]
print(all(liste))  # False
print(any(liste))  # True
```