# Objekte ohne Klassen in Python: Ein Vergleich mit JavaScript

In Python ist der übliche Weg, Objekte zu erstellen, die Definition einer `class`. Es gibt jedoch, ähnlich wie in JavaScript, Möglichkeiten, einfache, strukturierte Datenobjekte ohne eine formale Klassendefinition zu erstellen. Die gebräuchlichsten Methoden hierfür sind **Dictionaries** und **`collections.namedtuple`**.

---

## 1. Die Dictionary-Methode (Flexibel und Veränderlich)

Ein Python-Dictionary ist die direkteste Entsprechung zu einem JavaScript-Objektliteral. Es ist eine Sammlung von Schlüssel-Wert-Paaren und extrem flexibel.

**Merkmale:**
* **Veränderlich (Mutable):** Eigenschaften können zur Laufzeit hinzugefügt, geändert und entfernt werden.
* **Zugriff:** Der Zugriff auf Werte erfolgt über die `['key']`-Notation.
* **Methoden:** Funktionen (oft `lambda`) können als Werte gespeichert werden, um Methoden zu simulieren.

```python
# Erstellen eines "Objekts" als Dictionary
person_dict = {
    "vorname": "Anna",
    "nachname": "Muster",
    "alter": 30,
    "ist_aktiv": True,
    # Methode als Lambda-Funktion
    "ganzer_name": lambda self: f"{self['vorname']} {self['nachname']}"
}

# Zugriff auf Eigenschaften
print(f"Name: {person_dict['vorname']}") # -> Name: Anna
print(f"Alter: {person_dict['alter']}")   # -> Alter: 30

# Aufruf der "Methode"
# Wir übergeben das Dictionary an sich selbst, um den Kontext zu simulieren
print(f"Ganzer Name: {person_dict['ganzer_name'](person_dict)}") # -> Ganzer Name: Anna Muster

# Eigenschaften zur Laufzeit ändern oder hinzufügen
person_dict['alter'] = 31
person_dict['stadt'] = "Wien"
print(f"Neues Alter: {person_dict['alter']}") # -> Neues Alter: 31
print(f"Stadt: {person_dict['stadt']}")     # -> Stadt: Wien
```

---

## 2. Die `namedtuple`-Methode (Strukturiert und Unveränderlich)

Ein `namedtuple` ist eine Art "Mini-Klasse". Man definiert einmalig eine Vorlage mit festen Feldnamen und kann dann Instanzen davon erstellen.

**Merkmale:**
* **Unveränderlich (Immutable):** Nach der Erstellung können die Werte nicht mehr geändert werden.
* **Speichereffizient:** Benötigt weniger Speicher als ein Dictionary.
* **Zugriff:** Der Zugriff erfolgt über die saubere Punktnotation (`objekt.eigenschaft`), was den Code lesbarer macht.

```python
from collections import namedtuple

# Eine "Person"-Vorlage definieren
PersonTuple = namedtuple("Person", ["vorname", "nachname", "alter", "ist_aktiv"])

# Eine Instanz des "Objekts" erstellen
person_tuple = PersonTuple(
    vorname="Max",
    nachname="Meier",
    alter=42,
    ist_aktiv=False
)

# Zugriff auf Eigenschaften mit Punktnotation
print(f"Name: {person_tuple.vorname}") # -> Name: Max
print(f"Alter: {person_tuple.alter}")   # -> Alter: 42

# Versuch, einen Wert zu ändern, führt zu einem Fehler!
# person_tuple.alter = 43  # -> AttributeError: can't set attribute
```

---

## 3. Vergleich mit JavaScript-Objekten

JavaScript-Objektliterale sind syntaktisch und funktional fast identisch mit Python-Dictionaries.

```javascript
// Ein Objektliteral in JavaScript
const personJS = {
    vorname: "Anna",
    nachname: "Muster",
    alter: 30,
    ist_aktiv: true,
    // Methoden sind in JS eine Kernfunktion von Objekten
    ganzerName: function() {
        return `${this.vorname} ${this.nachname}`;
    }
};

// Zugriff auf Eigenschaften
console.log(`Name: ${personJS.vorname}`); // -> Name: Anna (Punktnotation)
console.log(`Alter: ${personJS['alter']}`);   // -> Alter: 30 (Bracket-Notation)

// Aufruf der Methode
console.log(`Ganzer Name: ${personJS.ganzerName()}`); // -> Ganzer Name: Anna Muster

// Eigenschaften zur Laufzeit ändern oder hinzufügen
personJS.alter = 31;
personJS.stadt = "Wien";
console.log(`Neues Alter: ${personJS.alter}`); // -> Neues Alter: 31
console.log(`Stadt: ${personJS.stadt}`);     // -> Stadt: Wien
```

---

## Zusammenfassung

| Merkmal | Python Dictionary | Python `namedtuple` | JavaScript Object |
| :--- | :--- | :--- | :--- |
| **Veränderlichkeit** | ✅ Ja (Mutable) | ❌ Nein (Immutable) | ✅ Ja (Mutable) |
| **Syntax** | `{ "key": value }` | `TypeName(value1, value2)` | `{ key: value }` |
| **Eigenschaftszugriff** | `obj['key']` | `obj.key` | `obj.key` oder `obj['key']` |
| **Methoden** | Simuliert (z.B. mit Lambda) | Nicht direkt vorgesehen | Nativ unterstützt |
| **Anwendungsfall** | Flexible Datenstrukturen, JSON-ähnliche Daten | Feste, unveränderliche Datencontainer | Flexible Datenstrukturen |