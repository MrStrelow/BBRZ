# De Morgans Gesetz und Guard Clauses
Wer verschachtelte ``If-Verzweigungen`` bereits verwendet hat, hat diese auch schon in deren Unübersichtlichkeit wahrgenommen.
Wir versuchen hier eine logisch "gleiche" Darstellung einer solchen Verzweigung zu finden, welche meistens leichter lesbar ist. Diese hat den Namen ``Guard Clause``.

## Verschachtelte ``If-Verzweigung``
Beginnen wir mit folgender verschachtelter **``If-Bedingung``** (``if`` ohne ``else`` ist eine ``If-Bedingung``). Hier überprüft der Code, ob eine Person mindestens 18 Jahre alt ist und ob sie einen Führerschein besitzt, bevor die Berechtigung zum Fahren ausgegeben wird. Hier ist jedoch versteckt, was passiert wenn wir jünger als 18 oder keinen Führerschein haben. Wir springen dann über beide ``If-Bedingungen``, falls wir die genannten Bedingungen nicht erfüllen. 

```csharp
if (age >= 18)
{
    if (hasLicense)
    {
        Console.WriteLine("Du darfst fahren.");
    }
}
```

Es scheint zuerst sinnlos folgendes zu tun. Schreiben wir den ``else`` Zweig hin, und verstecken ihn nicht durch das "drüberspringen" der Bedingungen, falls diese nicht erfüllt ist. Wir wandeln dazu ein ``If-Bedingung`` in eine ``If-Verzweigung`` um. Wir nennen nun den ``else`` Zweig den ``fehlerhafter Zustand`` und den ``if`` Zweig ``Korrekten Zustand``. 

```csharp
if (age >= 18)
{
    if (hasLicense)
    {
        Console.WriteLine("✅ Du darfst fahren."); // ✅ Korrekter Zustand
    }
    else  // Für den else Zweig ist die Bedingung !hasLicence. Diese ist versteckt, denn es ist !(hasLicence), und damit das Gegenteil der Bedingung im If.
    {
        return; // Fehlerhafter Zustand: Hier schreiben wir nichts, aber wir könnten sagen dass aufgrund der fehlenden Lizenz ein Faher verboten ist ❌
    }
}
else // für den else Zweig ist die Bedingung age < 18. Diese ist versteckt, denn es ist !(age >= 18), und damit das Gegenteil der Bedingung im If.
{
    return; // Fehlerhafter Zustand: Hier schreiben wir nichts, aber wir könnten sagen dass aufgrund der fehlenden Lizenz ein Faher verboten ist ❌
}
// ✅ Korrekter Zustand
```

**Anmerkung:** ``return`` wir hier allgemein ein *early exit* genannt. Gemeint ist, dass wir nicht weiter überprüfen ob die *Lizent* in Ordnung ist, wenn wir shcon wissen, dass das *Alter* nicht passt. Dieser Zustand kann auch erreicht werden wenn eine ``Exception`` geworfen wird. Es kann also ``return`` mit  ``throw new InvalidOperationException("Eine Fehlermeldung", ex);`` verwendet werden.

## Was ist eine Guard-Clause
Eine Guard-Clause will zuerst die ``fehlerhaften Zustände`` abfragen und dort einen *early exit* erzeugen. Dieser beendet die Funktion oder den Ablauf, wenn eine Bedingung nicht erfüllt ist. Wenn wir alle Bedingungen für ``fehlerhafte Zustände`` *nicht* erfüllen, dann sind wir in dem ``korrekten Zustand`` des Programmes. 

> Eine ``Guard-Clause`` ist eine Abfolge von "Sicherheitsabfragen" hintereinander. Wenn alle "bestanden" sind, sind wir in einem ``korrekten Zustand``.

Um das jedoch umsetzen zu können holen wir ein wenig aus. Wir schauen uns dazu ein *Gesetz* an welches in einer so genannten *Boolschen Algebra* gültig ist.

## De Morgans Gesetz
De Morgans Gesetz beschreibt zwei grundlegende Regeln zur Umwandlung von logischen Ausdrücken. Eine davon ist folgende:

> `!(A && B)` ist äquivalent zu `!A || !B`

Warum interessiert uns diese Gleichheit hier? Wir damit eine Regeln um zwischen "Welten" zu wechseln. Diese sind ähnlich den ``distributiv regeln`` aus der Schule. Mit diesen konnten wir zwischen eine "Plus" Welt und einer "Mal" Welt wechseln. In der "Mal Welt" konnten wir z.B. kürzen inder "Plus Welt" nicht. Wir wollen hier etwas ähnliches erreichen. Jedoch zuerst ein kleines Rätselraten...

## If-Verzweigungen, Logik und De Morgans Gesetz
### Logisches UND mit If-Verzweigungen
Können wir eine ``logische Formel`` finden welche das Verhalten des folgenden Codes wiederspiegelt? Versuchen wir eine Wahrheitstabelle aufzustellen. Das klingt abstrakt, jedoch stellen wir uns die Frage, *an welchem Ort im Programmcode ist A wahr oder falsch und wo ist B wahr oder falsch? Ein solches Verhalten von A und B stellt eine Zeile ein der Wahrheitstabelle dar.*.

```csharp
if (A)
{
    Console.Write("❔A gilt... also ist A && B... weder falsch noch wahr. Wir müssem wissen was B ist.");

    if (B) 
    {
        Console.Write("✅ A und B gilt... also ist A && B ist wahr");
    }
    else 
    {
        Console.Write("❌ Hier kommen wir nur her wenn B falsch ist. Es ist also A && B ebenso falsch");
        return;
    }
}
else 
{
    Console.Write("❌ Hier kommen wir nur her wenn A falsch ist. Es ist also A && B ebenso falsch");
    return;
}
// ✅ aber auch hier!
```

|    wo im programm?   | \( A \) | \( B \) | \( A $\land$ B \) |
|----------------------|---------|---------|------------------|
| im 2. if - und außerhalb des if  |   T     |   T     |         T        |
| im 2. else - return; |   T     |   F     |         T        |
| im 1. else - return; |   F     |   T     |         T        |
| im 1. else - return; |   F     |   F     |         F        |

Wir bemerken foldendes: Überall wo wir ein ``return`` bzw. wir in einem ``else`` Zweig sind, ist ein ❌ ``fehlerhafter Zustand`` und nur wenn ``A`` und ``B`` gleichzeitg gilt, ist ein ``✅ korrekten Zustand`` erreicht. Intuitiv klingt das nach einem ``logischen UND`` und wir verifizieren es in einer zusätzlichen Spalte in der Wahrheitstabelle \( A $\land$ B \).

### Logisches ODER mit If-Verzweigungen
Wenn wir uns vorheriges Programm anschauen haben wir die Korrekten Zustände aufgeteilt ✅❌❌✅, wenn wir von oben nach unten die Zustände auf fehlerhaft oder korrekt überprüfen. Wäre es nicht übersichtlicher wenn es ❌❌✅ wäre? Zuerst alle ``fehlerhafen`` dann der ``korrekte Zustände``?

Schauen wir uns diesen Code an. Schreiben wir uns alle Konbinationen von *true* und *false* der Variablen ``A`` und ``B`` in folgendem Programm in eine Wahrheitstabelle wie zuvor [hier](#logisches-und-mit-if-verzweigungen).

```csharp
if (X)
{
    Console.Write("✅X gilt... also ist X || Y ist wahr");
    return;
}
    
if (Y)
{
    Console.Write("✅Y gilt... also ist X || Y ist wahr");
    return;
}

Console.Write("❌Hier kommen wir nur her wenn A falsch ist und B falsch ist. Es ist also A || B ebenso falsch");
```

|    wo im programm?   | \( A \) | \( B \) | \( A $\lor$ B \) |
|----------------------|---------|---------|------------------|
| im 1. if return;     |   T     |   T     |         T        |
| im 1. if return;     |   T     |   F     |         T        |
| im 2. if return;     |   F     |   T     |         T        |
| unterhalb beider ifs |   F     |   F     |         F        |

Innerhalb der 1. ``If-Bedingung`` ist der Zustand ``A`` *wahr*. Darunter das gleiche Spiel nochmal mit ``B``. Wenn also nach den ``If-Bedingungen`` wir uns fragen, welche Formel hier gilt um in diesem Teil des Programmes zu kommen finden wir, dass hier sowie ``A`` und ``B`` *falsch* sein müssen. Ansosnten wären wir in die 1. oder 2. ``If-Bedingung`` "rein gegangen" und hätten durch ``return`` den Teil des Programmes verlassen. Wir bemerken also jedes mal wenn wir ``return`` aufrufen oder in eine ``If-Bedingung`` reingehen, ist ``A`` *wahr* oder ``B`` *wahr*. Intuitiv klingt das nach einem ``logischen ODER`` und wir verifizieren es in einer zusätzlichen Spalte in der Wahrheitstabelle \( A $\lor$ B \).

Hier ist ``return;`` wichtig! Ansonsten ist diese Konstrukt unterschiedlich zu dem ``||``. Auch bei ``&&`` jedoch ist es hier nicht so wichtig.

>Wir merken uns:
> * Das ``logische UND`` && bzw. $\land$ ist einer ``verschachtelten If-Verzweigung`` gleichzusetzen
> * Das ``logische ODER`` && bzw. $\lor$ ist einer ``untereinander geschriebenen If-Bedingung`` gleichzusetzen

**Die Frage:** Können wir immer eine *schwer lesbare* ``verschachtelten If-Verzweigung`` in eine *besser lesbare*``untereinander geschriebenen If-Bedingung`` umschreiben ohne die Bedeutung des Programmes zu ändern?*

**Die Antwort:** De Morgansche' Gesetz

### Wahrheitstabelle für das De Morgansche' Gesetz
Wieso gilt `!(A && B)` $\equiv$ `!A || !B`? Dazu lassen wir Intuition weg und schauen uns nur die Wahrheitstabelle an.
Wenn die spalten für beide Formeln für alle Zeilen gleich sind, sind die Formeln gleich.

| \( A \) | \( B \) | \( A $\land$ B \) | \( $\neg$ (A $\land$ B) \) | \( $\neg$ A \) | \( $\neg$ B \) | \( $\neg$ A $\lor$ $\neg$ B \) |
|---------|---------|------------------|-------------------------|--------------|--------------|---------------------------|
|   W     |   W     |         W        |           F             |      F       |      F       |            F              |
|   W     |   F     |         F        |           W             |      F       |      W       |            W              |
|   F     |   W     |         F        |           W             |      W       |      F       |            W              |
|   F     |   F     |         F        |           W             |      W       |      W       |            W              |

#### Erklärung der Tabelle:
Das Symbol $\land$ ist ``&&``, $\lor$ ist ``||`` und $\neg$ ist ``!`` in c#.
- **Spalten \( A \) und \( B \)**: Repräsentieren die möglichen Wahrheitswerte der Variablen \( A \) und \( B \).
- **Spalte \( A $\land$ B \)**: Das Ergebnis von \( A \) und \( B \) (Wahr, wenn beide wahr sind).
- **Spalte \( $\neg$$ (A $\land$ B) \)**: Die Negation von \( A $\land$ B \).
- **Spalte \( $\neg$ A \)**: Die Negation von \( A \).
- **Spalte \( $\neg$ B \)**: Die Negation von \( B \).
- **Spalte \( $\neg$ A $\lor$ $\neg$ B \)**: Das Ergebnis von \( $\neg$ A \) oder \( $\neg$ B \) (Wahr, wenn mindestens einer der beiden falsch ist).

## Vergleich

Die Spalten für \( $\neg$ (A $\land$ B) \) und \( $\neg$ A $\lor$ $\neg$ B \) sind in der Wahrheitstafel identisch, was zeigt, dass:

\[
$\neg$ (A $\land$ B) $\equiv$ $\neg$ A $\lor$ $\neg$ B
\]

Logisch gesehehen wollen wir A $\land$ B in  $\neg$($\neg$ A $\lor \neg$ B) umwandeln. Das funktioniert durch ``De Morgans Gesetzt``, wenn wir dieses einmal **negieren**. wir haben also A $\land$ B, was eine verschachteltes If darstellt und $\neg$ A $\lor \neg$ B was die IFs ``untereinander`` darstellt. Die letzte Negation ist dafür da, dass wir ``unterhalb`` der IFs ``true`` haben und nicht innerhalb der IFs.

Wir machen nun aber ein angewandteres Beispiel, welches nicht nur A und B als Bedingungen hat, sondern jene für eine Autofahrt (Führerschein und Alter).
Wir [erinnern](#de-morgans-gesetz) uns, dass ein *unternandergeschriebenes If-Bedingung + early exit* gleichbedeutend mit einem *logischen ODER* ist und ein *verschachteltes If-Verzweigung* mit einem *logischem UND*.

```csharp
if (age >= 18)
{
    if (hasLicense)
    {
        Console.WriteLine("✅ Du darfst fahren."); // ✅ Korrekter Zustand
    }
    else  // Für den else Zweig ist die Bedingung !hasLicence. Diese ist versteckt, denn es ist !(hasLicence), und damit das Gegenteil der Bedingung im If.
    {
        return; // Fehlerhafter Zustand: Hier schreiben wir nichts, aber wir könnten sagen dass aufgrund der fehlenden Lizenz ein Faher verboten ist ❌
    }
}
else // für den else Zweig ist die Bedingung age < 18. Diese ist versteckt, denn es ist !(age >= 18), und damit das Gegenteil der Bedingung im If.
{
    return; // Fehlerhafter Zustand: Hier schreiben wir nichts, aber wir könnten sagen dass aufgrund der fehlenden Lizenz ein Faher verboten ist ❌
}
// ✅ Korrekter Zustand
```

Wandeln wir um in...
```csharp
// ❌
if (age < 18)
{
    return;
}

// ❌
if (!hasLicense)
{
    return;
} 

// ✅
Console.WriteLine("Du darfst fahren.");
```

oder anders geschrieben

```csharp
// ❌
if (age < 18 || !hasLicense) 
{
    return;
}

// ✅
Console.WriteLine("Du darfst fahren.");
```

### Verschachtelte If-Verzweigung
Wir haben bis jetzt verschachtelte ``IF-Bedingungen`` gesehen, welche keinen ``else`` Zweig hatten. Wir schauen uns nun verschachtelte``IF-Verzweigungen`` an.

Folgender Code ist nicht sehr spannend, denn die ``else``zweige können 
```csharp
if (age >= 18)
{
    if (hasLicense)
    {
        Console.WriteLine("Du darfst fahren.");
    }
    else 
    {
        return;
    }
}
else 
{
    return;
}
```

## Ein komplizierteres Beispiel